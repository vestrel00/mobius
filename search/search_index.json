{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mobius is a functional reactive framework for managing state evolution and side-effects, with add-ons for connecting to Android UIs and RxJava Observables. It emphasizes separation of concerns, testability, and isolating stateful parts of the code. To learn more, visit the website for a user guide. To see Mobius in action, check out the sample TODO app based on the app from Android Architecture Blueprints . You can also watch a talk from Android @Scale introducing Mobius . Status \u00b6 Mobius is in Production status, meaning it is used in production in Spotify Android applications, and that we consider the APIs to be stable and the implementation bug-free. We will not make backwards-compatibility-breaking changes. Mobius is currently built for Java 7 (because Java 8 is not fully supported on all versions of Android), hence the duplication of some concepts defined in java.util.function (see com.spotify.mobius.functions ). When using Mobius, we recommend using Kotlin or Java 8 or later, primarily because of the improved type inference and because using lambdas greatly improves readability and conciseness of code. Using it in your project \u00b6 The latest version of Mobius is available through Maven Central (LATEST_RELEASE below is ): implementation 'com.spotify.mobius:mobius-core:LATEST_RELEASE' testImplementation 'com.spotify.mobius:mobius-test:LATEST_RELEASE' implementation 'com.spotify.mobius:mobius-rx:LATEST_RELEASE' // only for RxJava 1 support implementation 'com.spotify.mobius:mobius-rx2:LATEST_RELEASE' // only for RxJava 2 support implementation 'com.spotify.mobius:mobius-rx3:LATEST_RELEASE' // only for RxJava 3 support implementation 'com.spotify.mobius:mobius-android:LATEST_RELEASE' // only for Android support implementation 'com.spotify.mobius:mobius-extras:LATEST_RELEASE' // utilities for common patterns mobius-core \u00b6 This is the core of Mobius, which all other modules depend on. It is a pure Java library that is completely self-contained. This is the only module that you need when using Mobius, because the others are optional extensions to the core. mobius-test \u00b6 The test module contains utilities that help you write tests for Mobius applications. It should only be used as a test dependency. mobius-rx / mobius-rx2 / mobius-rx3 \u00b6 The rx modules contain extensions for RxJava. You should use one of them in your Mobius applications since they simplify creating effect handlers and event sources. Both RxJava modules share the same API, the only difference is that one is built for RxJava 1.x and the other for RxJava 2.x. mobius-android \u00b6 The android module primarily contains classes for hooking up a MobiusLoop to Android. mobius-extras \u00b6 The extras module contains utilities and classes that help reducing boilerplate for some more advanced usage patterns (for example, nested update functions). Mobius in Action - Building a Counter \u00b6 The goal of Mobius is to give you better control over your application state. You can think of your state as a snapshot of all the current values of the variables in your application. In Mobius, we encapsulate all of the state in a data-structure which we call the Model . The Model can be represented by whatever type you like. In this example we'll be building a simple counter, so all of our state can be contained in an Integer : Mobius does not let you manipulate the state directly. In order to change the state, you have to send the framework messages saying what you want to do. We call these messages Events . In our case, we'll want to increment and decrement our counter. Let's use an enum to define these cases: enum CounterEvent { INCREMENT , DECREMENT , } Now that we have a Model and some Event s, we'll need to give Mobius a set of rules which it can use to update the state on our behalf. We do this by giving the framework a function which will be sequentially called with every incoming Event and the most recent Model , in order to generate the next Model : class CounterLogic { static Integer update ( Integer model , CounterEvent event ) { switch ( event ) { case INCREMENT : return model + 1 ; case DECREMENT : return model - 1 ; } } } With these building blocks, we can start to think about our applications as transitions between discrete states in response to events. But we believe there is still one piece missing from the puzzle - namely the side-effects which are associated with moving between states. For instance, pressing a \"refresh\" button might put our application into a \"loading\" state, with the side-effect of also fetching the latest data from our backend. In Mobius, we aptly call these side-effects Effect s. In the case of our counter, let's say that when the user tries to decrement below 0, we play a sound effect instead. Let's create an enum that represents all the possible effects (which in this case is only one): enum CounterEffect { PLAY_SOUND , } We'll now need to augment our update function to also return a set of effects associated with certain state transitions. To do this we'll implement the Update interface like so: class CounterLogic implements Update < Integer , CounterEvent , CounterEffect > { public Next < Integer , CounterEffect > update ( Integer model , CounterEvent event ) { switch ( event ) { case INCREMENT : return next ( model + 1 ); case DECREMENT : if ( model == 0 ) { Set < CounterEffect > soundEffect = effects ( CounterEffect . PLAY_SOUND ); return dispatch ( soundEffect ); } return next ( model - 1 ); } throw new IllegalStateException ( \"Unhandled event: \" + event ); } } Mobius sends each of the effects you return in any state transition to something called an Effect Handler . Let's make one of those now by implementing the Connectable interface: class CounterEffectHandler implements Connectable < CounterEffect , CounterEvent > { public Connection < CounterEffect > connect ( Consumer < CounterEvent > output ) { return new Connection < CounterEffect > () { @Override public void accept ( CounterEffect effect ) { if ( effect == CounterEffect . PLAY_SOUND ) { Toolkit . getDefaultToolkit (). beep (); } } @Override public void dispose () {} }; } } Now that we have all the pieces in place, let's tie it all together: public static void main ( String [] args ) { // Let's make a Mobius Loop MobiusLoop < Integer , CounterEvent , CounterEffect > loop = Mobius . loop ( new CounterLogic (), new CounterEffectHandler ()) . startFrom ( 0 ); // And start using our loop loop . dispatchEvent ( CounterEvent . INCREMENT ); // Model is now 1 loop . dispatchEvent ( CounterEvent . DECREMENT ); // Model is now 0 loop . dispatchEvent ( CounterEvent . DECREMENT ); // Sound effect plays! Model is still 0 } This covers the fundamentals of Mobius. To learn more, head on over to our website . Building \u00b6 Formatting \u00b6 We're using Google's auto-formatter to format the code. The build pipeline is set up to fail builds that aren't correctly formatted. To ensure correct formatting, run ./gradlew format Code of Conduct \u00b6 This project adheres to the Open Code of Conduct . By participating, you are expected to honor this code.","title":"Overview"},{"location":"#status","text":"Mobius is in Production status, meaning it is used in production in Spotify Android applications, and that we consider the APIs to be stable and the implementation bug-free. We will not make backwards-compatibility-breaking changes. Mobius is currently built for Java 7 (because Java 8 is not fully supported on all versions of Android), hence the duplication of some concepts defined in java.util.function (see com.spotify.mobius.functions ). When using Mobius, we recommend using Kotlin or Java 8 or later, primarily because of the improved type inference and because using lambdas greatly improves readability and conciseness of code.","title":"Status"},{"location":"#using-it-in-your-project","text":"The latest version of Mobius is available through Maven Central (LATEST_RELEASE below is ): implementation 'com.spotify.mobius:mobius-core:LATEST_RELEASE' testImplementation 'com.spotify.mobius:mobius-test:LATEST_RELEASE' implementation 'com.spotify.mobius:mobius-rx:LATEST_RELEASE' // only for RxJava 1 support implementation 'com.spotify.mobius:mobius-rx2:LATEST_RELEASE' // only for RxJava 2 support implementation 'com.spotify.mobius:mobius-rx3:LATEST_RELEASE' // only for RxJava 3 support implementation 'com.spotify.mobius:mobius-android:LATEST_RELEASE' // only for Android support implementation 'com.spotify.mobius:mobius-extras:LATEST_RELEASE' // utilities for common patterns","title":"Using it in your project"},{"location":"#mobius-core","text":"This is the core of Mobius, which all other modules depend on. It is a pure Java library that is completely self-contained. This is the only module that you need when using Mobius, because the others are optional extensions to the core.","title":"mobius-core"},{"location":"#mobius-test","text":"The test module contains utilities that help you write tests for Mobius applications. It should only be used as a test dependency.","title":"mobius-test"},{"location":"#mobius-rx-mobius-rx2-mobius-rx3","text":"The rx modules contain extensions for RxJava. You should use one of them in your Mobius applications since they simplify creating effect handlers and event sources. Both RxJava modules share the same API, the only difference is that one is built for RxJava 1.x and the other for RxJava 2.x.","title":"mobius-rx  / mobius-rx2   / mobius-rx3"},{"location":"#mobius-android","text":"The android module primarily contains classes for hooking up a MobiusLoop to Android.","title":"mobius-android"},{"location":"#mobius-extras","text":"The extras module contains utilities and classes that help reducing boilerplate for some more advanced usage patterns (for example, nested update functions).","title":"mobius-extras"},{"location":"#mobius-in-action-building-a-counter","text":"The goal of Mobius is to give you better control over your application state. You can think of your state as a snapshot of all the current values of the variables in your application. In Mobius, we encapsulate all of the state in a data-structure which we call the Model . The Model can be represented by whatever type you like. In this example we'll be building a simple counter, so all of our state can be contained in an Integer : Mobius does not let you manipulate the state directly. In order to change the state, you have to send the framework messages saying what you want to do. We call these messages Events . In our case, we'll want to increment and decrement our counter. Let's use an enum to define these cases: enum CounterEvent { INCREMENT , DECREMENT , } Now that we have a Model and some Event s, we'll need to give Mobius a set of rules which it can use to update the state on our behalf. We do this by giving the framework a function which will be sequentially called with every incoming Event and the most recent Model , in order to generate the next Model : class CounterLogic { static Integer update ( Integer model , CounterEvent event ) { switch ( event ) { case INCREMENT : return model + 1 ; case DECREMENT : return model - 1 ; } } } With these building blocks, we can start to think about our applications as transitions between discrete states in response to events. But we believe there is still one piece missing from the puzzle - namely the side-effects which are associated with moving between states. For instance, pressing a \"refresh\" button might put our application into a \"loading\" state, with the side-effect of also fetching the latest data from our backend. In Mobius, we aptly call these side-effects Effect s. In the case of our counter, let's say that when the user tries to decrement below 0, we play a sound effect instead. Let's create an enum that represents all the possible effects (which in this case is only one): enum CounterEffect { PLAY_SOUND , } We'll now need to augment our update function to also return a set of effects associated with certain state transitions. To do this we'll implement the Update interface like so: class CounterLogic implements Update < Integer , CounterEvent , CounterEffect > { public Next < Integer , CounterEffect > update ( Integer model , CounterEvent event ) { switch ( event ) { case INCREMENT : return next ( model + 1 ); case DECREMENT : if ( model == 0 ) { Set < CounterEffect > soundEffect = effects ( CounterEffect . PLAY_SOUND ); return dispatch ( soundEffect ); } return next ( model - 1 ); } throw new IllegalStateException ( \"Unhandled event: \" + event ); } } Mobius sends each of the effects you return in any state transition to something called an Effect Handler . Let's make one of those now by implementing the Connectable interface: class CounterEffectHandler implements Connectable < CounterEffect , CounterEvent > { public Connection < CounterEffect > connect ( Consumer < CounterEvent > output ) { return new Connection < CounterEffect > () { @Override public void accept ( CounterEffect effect ) { if ( effect == CounterEffect . PLAY_SOUND ) { Toolkit . getDefaultToolkit (). beep (); } } @Override public void dispose () {} }; } } Now that we have all the pieces in place, let's tie it all together: public static void main ( String [] args ) { // Let's make a Mobius Loop MobiusLoop < Integer , CounterEvent , CounterEffect > loop = Mobius . loop ( new CounterLogic (), new CounterEffectHandler ()) . startFrom ( 0 ); // And start using our loop loop . dispatchEvent ( CounterEvent . INCREMENT ); // Model is now 1 loop . dispatchEvent ( CounterEvent . DECREMENT ); // Model is now 0 loop . dispatchEvent ( CounterEvent . DECREMENT ); // Sound effect plays! Model is still 0 } This covers the fundamentals of Mobius. To learn more, head on over to our website .","title":"Mobius in Action - Building a Counter"},{"location":"#building","text":"","title":"Building"},{"location":"#formatting","text":"We're using Google's auto-formatter to format the code. The build pipeline is set up to fail builds that aren't correctly formatted. To ensure correct formatting, run ./gradlew format","title":"Formatting"},{"location":"#code-of-conduct","text":"This project adheres to the Open Code of Conduct . By participating, you are expected to honor this code.","title":"Code of Conduct"},{"location":"concepts/","text":"Concepts \u00b6 This document is intended as a quick overview of the core concepts in Mobius. The terms have detailed explanations in the Reference Guide section of the wiki, but it's best to familiarise yourself with this overview before going in depth. Mobius Loop \u00b6 A Mobius loop is a part of an application, usually including a user interface. In a Spotify context, there is usually one loop per feature such as \u201cthe album page\u201d, \u201clogin flow\u201d, etc., but a loop can also be UI-less and for instance be tied to the lifecycle of an application or a user session. A Mobius loop receives Events , which are passed to an Update function together with the current Model . As a result of running the Update function, the Model might change, and Effects might get dispatched. The Model can be observed by the user interface, and the Effects are received and executed by an Effect Handler . 'Pure' in the diagram refers to pure functions, functions whose output only depends on their inputs, and whose execution has no observable side effects. See Pure vs Impure Functions for more details. Event \u00b6 Events occur in and around the loop and act as triggers for state-changing business logic, for example: User actions in the UI, such as submitting a query by typing into a text field, or clicking on a checkbox. Responses from backend services. System events like changes in network availability. Events in Mobius are implemented as immutable data objects. Events often have different payloads (or no payload). So a QueryUpdated event almost certainly has the actual query string attached, whereas a ClearHistory event probably doesn\u2019t need any payload. A SearchResultReceived event includes the response from the search backend, and so on. Model \u00b6 The model is an immutable representation of the loop\u2019s state from a business logic perspective - that is, decoupled from the UI. The Model and the Event must contain all the data that the Update function needs in order to make decisions when an Event happens, since the Update function must be pure and therefore cannot read state externally. What\u2019s presented in the UI should be derivable from the model, but it doesn\u2019t have to be identical. So concatenated strings, formatted dates, etc., don\u2019t need to be included in the model. Instead they can be calculated when the UI is updated. Note: The expression \u201cfrom a business logic perspective\u201d means that canLogin is a good name for a field in the model, but loginButtonEnabled is not. The latter is more appropriate in the UI. Effect \u00b6 Sometimes, you need to change or fetch information that currently isn\u2019t in the Model (for example, data that resides in a backend service). You do this in Mobius with Effects. The term \u2018Effect\u2019 was chosen because it is similar to \u2018side effect\u2019. 'Effect' in Mobius is a description of a desired impure function invocation, not the invocation itself. You can think of it as a statement that \"I want to send a search request with the query string 'foo'\", and not than an invocation of api.search(\"foo\") . We sometimes distinguish between Effect description (immutable messages) and Effect execution (making the desired Effect actually happen). The difference between Events and Effects is that Events are external things that happen and are inputs to the Mobius loop, whereas Effects are outputs from the Mobius loop; things the loop wants to do in the outside world. A common example of an Effect is sending a backend request. Even if this doesn\u2019t mutate any state, it\u2019s still an impure function as it involves a network call, and leads to different results depending on the network connection and the current state of the backend services. Similar to Events, Effects normally have different payloads depending on what they describe. An AttemptLogin Effect would include a username and password, and an UpdateAddress effect would contain the new address data. Update Function \u00b6 This is the heart of a Mobius loop. It has the following signature: Next < M , F > update ( M model , E event ) Picking that apart, the method takes a Model with the current state and an Event, and returns a Next object. The Next object may contain a new Model if the state should be changed for the next Update invocation, and always has a (possibly empty) set of Effects that should be triggered. Update functions must be pure. The Update function is declarative, in the sense that it declares what should happen, but doesn\u2019t actually do anything itself. It returns a Next that describes the desired changes - possibly a new Model, and possibly some Effects that should be executed - but actually changing the Model and executing the Effects happens elsewhere. For each incoming Event, Mobius invokes the Update function and atomically replaces the Model (if the Update function specifies that a new one is needed) before handling the next Event. This sequencing of Events, combined with the immutability of Events, Effects and Models, means that there are no data races in the loop itself. Starting and resuming a loop \u00b6 You frequently need to start things when initialising or resuming a Mobius loop. This can entail firing off requests to load data, etc. Mobius supports two ways for doing this, either through passing in a set of initial effects to MobiusLoop.startFrom(M model, Set<F> startEffects) , or through the Init function, which has the following signature: First < M , F > init ( M model ) That is, given a Model, it returns a Model and a set of Effects to run. The Model that Init gets invoked with is normally either a 'starting' Model, or a 'saved' Model that has been restored. Init may return the Model unchanged, or change it, and it may also return Effects that kick off things that allow the loop to make progress. An example: if a loop is paused in an Error state because loading data from the backend has failed and then resumed, the Init function can return a Loading state and an Effect that retries the backend request. The recommendation is to use the Init function together with MobiusController, as it is mostly useful for loops that get started and stopped; for one-shot loops, passing in a set of initial effects to run is easier. Effect Handler \u00b6 Once the Update function has dispatched an Effect, something needs to execute it. That is the job of Effect Handlers. An Effect Handler consumes Effects and (usually) produces Events. A common example of an Effect Handler task is to send a request to a backend service and when a response arrives, translate the response into an Event for the Update function. Effect Handlers are not allowed to throw exceptions, instead they should convert errors into Events that the Update function can react to (eg. triggering a fallback mechanism or giving the user feedback). UI \u00b6 Building user interfaces (not necessarily graphical) is what Mobius has been created to do, but UIs are optional. It's often a good idea to build a UI-less Mobius loop for managing the state evolution of something without a user interface. The primary way of connecting your UI to the business logic in the Update function is by observing Model changes. Each time the Model changes, the UI will get notified and can update its state accordingly. This means that the UI is similar to an Effect Handler, but consumes Models (not Effects) while still producing Events. Typically, parts of the Model will be bound to widgets (\" views\" in Android parlance) in the UI, so that a boolean field in the Model can enable or disable a button, etc. Where Next? \u00b6 If you would like a hands-on example, take a look at the Getting Started guide , and if you prefer understanding more of the theory, then continue learning more about the objectives of Mobius.","title":"Concepts"},{"location":"concepts/#concepts","text":"This document is intended as a quick overview of the core concepts in Mobius. The terms have detailed explanations in the Reference Guide section of the wiki, but it's best to familiarise yourself with this overview before going in depth.","title":"Concepts"},{"location":"concepts/#mobius-loop","text":"A Mobius loop is a part of an application, usually including a user interface. In a Spotify context, there is usually one loop per feature such as \u201cthe album page\u201d, \u201clogin flow\u201d, etc., but a loop can also be UI-less and for instance be tied to the lifecycle of an application or a user session. A Mobius loop receives Events , which are passed to an Update function together with the current Model . As a result of running the Update function, the Model might change, and Effects might get dispatched. The Model can be observed by the user interface, and the Effects are received and executed by an Effect Handler . 'Pure' in the diagram refers to pure functions, functions whose output only depends on their inputs, and whose execution has no observable side effects. See Pure vs Impure Functions for more details.","title":"Mobius Loop"},{"location":"concepts/#event","text":"Events occur in and around the loop and act as triggers for state-changing business logic, for example: User actions in the UI, such as submitting a query by typing into a text field, or clicking on a checkbox. Responses from backend services. System events like changes in network availability. Events in Mobius are implemented as immutable data objects. Events often have different payloads (or no payload). So a QueryUpdated event almost certainly has the actual query string attached, whereas a ClearHistory event probably doesn\u2019t need any payload. A SearchResultReceived event includes the response from the search backend, and so on.","title":"Event"},{"location":"concepts/#model","text":"The model is an immutable representation of the loop\u2019s state from a business logic perspective - that is, decoupled from the UI. The Model and the Event must contain all the data that the Update function needs in order to make decisions when an Event happens, since the Update function must be pure and therefore cannot read state externally. What\u2019s presented in the UI should be derivable from the model, but it doesn\u2019t have to be identical. So concatenated strings, formatted dates, etc., don\u2019t need to be included in the model. Instead they can be calculated when the UI is updated. Note: The expression \u201cfrom a business logic perspective\u201d means that canLogin is a good name for a field in the model, but loginButtonEnabled is not. The latter is more appropriate in the UI.","title":"Model"},{"location":"concepts/#effect","text":"Sometimes, you need to change or fetch information that currently isn\u2019t in the Model (for example, data that resides in a backend service). You do this in Mobius with Effects. The term \u2018Effect\u2019 was chosen because it is similar to \u2018side effect\u2019. 'Effect' in Mobius is a description of a desired impure function invocation, not the invocation itself. You can think of it as a statement that \"I want to send a search request with the query string 'foo'\", and not than an invocation of api.search(\"foo\") . We sometimes distinguish between Effect description (immutable messages) and Effect execution (making the desired Effect actually happen). The difference between Events and Effects is that Events are external things that happen and are inputs to the Mobius loop, whereas Effects are outputs from the Mobius loop; things the loop wants to do in the outside world. A common example of an Effect is sending a backend request. Even if this doesn\u2019t mutate any state, it\u2019s still an impure function as it involves a network call, and leads to different results depending on the network connection and the current state of the backend services. Similar to Events, Effects normally have different payloads depending on what they describe. An AttemptLogin Effect would include a username and password, and an UpdateAddress effect would contain the new address data.","title":"Effect"},{"location":"concepts/#update-function","text":"This is the heart of a Mobius loop. It has the following signature: Next < M , F > update ( M model , E event ) Picking that apart, the method takes a Model with the current state and an Event, and returns a Next object. The Next object may contain a new Model if the state should be changed for the next Update invocation, and always has a (possibly empty) set of Effects that should be triggered. Update functions must be pure. The Update function is declarative, in the sense that it declares what should happen, but doesn\u2019t actually do anything itself. It returns a Next that describes the desired changes - possibly a new Model, and possibly some Effects that should be executed - but actually changing the Model and executing the Effects happens elsewhere. For each incoming Event, Mobius invokes the Update function and atomically replaces the Model (if the Update function specifies that a new one is needed) before handling the next Event. This sequencing of Events, combined with the immutability of Events, Effects and Models, means that there are no data races in the loop itself.","title":"Update Function"},{"location":"concepts/#starting-and-resuming-a-loop","text":"You frequently need to start things when initialising or resuming a Mobius loop. This can entail firing off requests to load data, etc. Mobius supports two ways for doing this, either through passing in a set of initial effects to MobiusLoop.startFrom(M model, Set<F> startEffects) , or through the Init function, which has the following signature: First < M , F > init ( M model ) That is, given a Model, it returns a Model and a set of Effects to run. The Model that Init gets invoked with is normally either a 'starting' Model, or a 'saved' Model that has been restored. Init may return the Model unchanged, or change it, and it may also return Effects that kick off things that allow the loop to make progress. An example: if a loop is paused in an Error state because loading data from the backend has failed and then resumed, the Init function can return a Loading state and an Effect that retries the backend request. The recommendation is to use the Init function together with MobiusController, as it is mostly useful for loops that get started and stopped; for one-shot loops, passing in a set of initial effects to run is easier.","title":"Starting and resuming a loop"},{"location":"concepts/#effect-handler","text":"Once the Update function has dispatched an Effect, something needs to execute it. That is the job of Effect Handlers. An Effect Handler consumes Effects and (usually) produces Events. A common example of an Effect Handler task is to send a request to a backend service and when a response arrives, translate the response into an Event for the Update function. Effect Handlers are not allowed to throw exceptions, instead they should convert errors into Events that the Update function can react to (eg. triggering a fallback mechanism or giving the user feedback).","title":"Effect Handler"},{"location":"concepts/#ui","text":"Building user interfaces (not necessarily graphical) is what Mobius has been created to do, but UIs are optional. It's often a good idea to build a UI-less Mobius loop for managing the state evolution of something without a user interface. The primary way of connecting your UI to the business logic in the Update function is by observing Model changes. Each time the Model changes, the UI will get notified and can update its state accordingly. This means that the UI is similar to an Effect Handler, but consumes Models (not Effects) while still producing Events. Typically, parts of the Model will be bound to widgets (\" views\" in Android parlance) in the UI, so that a boolean field in the Model can enable or disable a button, etc.","title":"UI"},{"location":"concepts/#where-next","text":"If you would like a hands-on example, take a look at the Getting Started guide , and if you prefer understanding more of the theory, then continue learning more about the objectives of Mobius.","title":"Where Next?"},{"location":"faq/","text":"FAQ \u00b6 How do I re-render only the part of the UI that changed when I get a new model? \u00b6 We believe Mobius is and will be a better framework if it\u2019s focused on a single job. That job is managing changes in state over time, not how to present that state to the user. It is straightforward to build a layer between Mobius and the view layer that figures out what has changed in the model and what hasn\u2019t, forwarding only changes to the View. But such a layer should be considered an add-on on top of Mobius, and will never be part of the core Mobius library. In a typical presenter there are already cases where you get external data and have to \u201cdiff\u201d it against the old data, and doing that diffing \u201cmanually\u201d is often reasonably straight forward. The only difference when using Mobius is that you get the data from the MobiusLoop rather than directly from the data source. Is Mobius an alternative to MV*? \u00b6 Yes and no, but mostly no. Mobius isn\u2019t a direct replacement or an alternative to MV (meaning MVC, MVP, MVVM, etc.), but it works very well as a building block in the various MV patterns, and it concerns itself with primarily the M part of the problem that the MV* patterns approach. Mobius defines a way to organise your business logic (the things that usually go into the \u2018M\u2019 in MV* , think \u201cinteractors\u201d and \u201cuse cases\u201d from Clean Architecture), and gives you a unidirectional interface between business logic and the view (in the form of events and models). This means it can be used as a replacement for the \u2018M\u2019 in for instance MVP or MVVM, keeping the relationship between Presenter/ViewModel and the \u2018V\u2019 unchanged. Since Mobius will give you a model with all the data you need in one place, a Presenter/ViewModel used in conjunction with a MobiusLoop usually ends up doing little more than just formatting data for the view, (eg. converting Date objects into formatted strings.) and dispatching Events back to the loop. If you don\u2019t want that layer of indirection, then Mobius can be thought of as an alternative to MV* - you can use just a MobiusLoop and a View, with no need for a third thing that connects them.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#how-do-i-re-render-only-the-part-of-the-ui-that-changed-when-i-get-a-new-model","text":"We believe Mobius is and will be a better framework if it\u2019s focused on a single job. That job is managing changes in state over time, not how to present that state to the user. It is straightforward to build a layer between Mobius and the view layer that figures out what has changed in the model and what hasn\u2019t, forwarding only changes to the View. But such a layer should be considered an add-on on top of Mobius, and will never be part of the core Mobius library. In a typical presenter there are already cases where you get external data and have to \u201cdiff\u201d it against the old data, and doing that diffing \u201cmanually\u201d is often reasonably straight forward. The only difference when using Mobius is that you get the data from the MobiusLoop rather than directly from the data source.","title":"How do I re-render only the part of the UI that changed when I get a new model?"},{"location":"faq/#is-mobius-an-alternative-to-mv","text":"Yes and no, but mostly no. Mobius isn\u2019t a direct replacement or an alternative to MV (meaning MVC, MVP, MVVM, etc.), but it works very well as a building block in the various MV patterns, and it concerns itself with primarily the M part of the problem that the MV* patterns approach. Mobius defines a way to organise your business logic (the things that usually go into the \u2018M\u2019 in MV* , think \u201cinteractors\u201d and \u201cuse cases\u201d from Clean Architecture), and gives you a unidirectional interface between business logic and the view (in the form of events and models). This means it can be used as a replacement for the \u2018M\u2019 in for instance MVP or MVVM, keeping the relationship between Presenter/ViewModel and the \u2018V\u2019 unchanged. Since Mobius will give you a model with all the data you need in one place, a Presenter/ViewModel used in conjunction with a MobiusLoop usually ends up doing little more than just formatting data for the view, (eg. converting Date objects into formatted strings.) and dispatching Events back to the loop. If you don\u2019t want that layer of indirection, then Mobius can be thought of as an alternative to MV* - you can use just a MobiusLoop and a View, with no need for a third thing that connects them.","title":"Is Mobius an alternative to MV*?"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"objectives/","text":"Objectives \u00b6 Mobius was designed with some specific objectives in mind, and it\u2019s going to be easier both to use it correctly and to understand some of the design decisions if you know the underlying thinking. The original objectives we set out to achieve were: Strong separation of concerns in general, and specifically between presentation logic and business logic. Encourage maximal use of pure functions . Great testability through the design itself as well as included tooling. Ease of understanding systems' behaviour in terms of concurrency and ordering . The next couple of sections describe how Mobius achieves those objectives. Separation of Concerns \u00b6 Mobius ensures or encourages separation in the following ways: Separating what should happen from how it happens . Effects are requested by the Update function, and performed by Effect handlers. Separating handling of different kinds of Effect from one another . Through making it easy and recommended to implement individual Effect handlers for each Effect. Clarifying that UI state is different from loop state (the current Model) . Most of the UI state will be derivable from the loop state/Model, but not all of it. Examples of the latter include things like the current position in a text field, the current state of animation (usually) , etc. It\u2019s perfectly OK to have state in the UI, but you maximise the benefit you get from Mobius by minimising that state. Processing of Events happens sequentially, one Event at the time . This means that there can be no data races in the Update function. However, note that Mobius doesn't provide any guarantees at all about Event or Effect ordering, and we strongly recommend that you ensure that your Update functions are robust in the face of out-of-expected-order Events (strictly speaking, since there are no ordering guarantees, there can be no out-of-order Events). Pure Functions \u00b6 Mutable state makes programs hard to understand, because it introduces the notion of change over time. To understand how something behaves, you must understand what has happened before so you can know the current state of the object. Pure functions, on the other hand, are predictable, making them easier to understand and test because their behaviour is entirely defined by their inputs. But mutable state is necessary in any interesting program. Mobius restricts mutable state to the following places, allowing you to implement the rest of the code as pure functions: In the UI : Most UI frameworks have lots of mutable state, such as the contents of or cursor position in a text field, the current state of an animation, etc. This state is separate from the Model, which holds the business logic state. Internals of MobiusLoop . The Model object must be immutable, but to support changing the internal state of the loop, Mobius tracks a reference to the current Model. As a user, you don\u2019t need to worry about this, because your Update and Init functions are pure functions. Persistent or feature-external state , such as the \u2018recent searches\u2019 history tracked by a Search feature, or the state of a Spotify user\u2019s playlists. A change to this type of state is made using an Effect that describes the desired change, and an Effect Handler that executes the actual change. Testability \u00b6 We believe having a great set of tests for your code is one of the best ways to ensure you can be productive when coding, because great tests quickly give you feedback about mistakes made when you evolve your code. Great tests are characterised by: Short run times to get quick feedback cycles - subsecond is ideal. Small scope for errors => more precise reporting of what's broken. When something breaks, it should be obvious where in the system it broke. Sufficient coverage of branches and lines. Loose coupling with production code. Tests that use a lot of mocks and other ways of verifying that the system under test had side effects tend to be closely tied to the production code. It is better to write tests as \"Given an initial state, When X happens, Then the state is Y\" - rather than, \"Then method A on collaborator B was invoked with parameters C and D\". Adhering to the Single Responsibility principle - a test should have only one reason to change and/or fail. Violating the SRP for tests is a thing that greatly reduces evolvability of the system, because intended changes to production code lead to lots of unrelated changes to test code. The test code becomes a dead weight you have to drag around. Mobius helps to achieve these kinds of tests through: Pure functions that make it easy to get great coverage. They have no state-space, so less combinatorial explosion internally. Pure functions that make it unnecessary to verify side effects through mocks and spies. Strong separation of concerns that enables writing small tests (in the sense of how much production code a test covers). Small tests are faster and more precise, and more likely to have a single responsibility. Testing utilities ( see UpdateSpec and InitSpec especially) that make it convenient to write good outside-in tests. A recommended workflow that includes writing business logic tests before implementing it. This helps ensure there is no coupling with the production code - since it hasn\u2019t been written yet, it\u2019s not possible to couple your tests to it. Concurrency and Ordering \u00b6 It is notoriously hard to write robust code when things can happen in any order, and in mobile apps, changes can come from the user, the system, or a backend service with no way of effectively controlling ordering. The first property of Mobius that helps make understanding a loop's behaviour is the sequential and atomic Event processing. Since the only thing that can change the loop\u2019s state is an Event arriving, and only one Event is processed at a given time, there are no data races in the loop itself. In contrast, a multi-threaded solution where a click listener might be modifying some mutable state concurrently with a response from backend server gets harder to understand. Second, since all Events and Effects are simple value objects, the history of processed Events and resulting Models and Effects provides excellent troubleshooting information. Mobius provides no guarantees about the execution order of Effects or arrival order of Events. The reason is that that\u2019s what the world is like, when you\u2019re doing distributed computing. You never know what\u2019s going to happen to requests you send somewhere else. So if you send a request from a client to some backend server, and you don\u2019t get a response, that could be caused by any of the following: The request got lost somewhere The response got lost somewhere The request or response is still en route and a response will arrive if you just wait \u2018a little longer\u2019 An implication of that is that if you send two requests from a client to a backend service, you don\u2019t know that the responses will arrive in the same order as the requests were sent. So in Mobius, we recommend that you ensure that your business logic can handle Events arriving in any order in a robust way. An example that shows some of the complexity is a signup process where the following happens: Event SignupRequested : The user clicks \"register\". Effect CreateAccount(username, password) : The Update function tries to create an account using an effect. Event AccountCreationTimedOut() : The Effect Handler decides a response is unlikely to happen. Event SignupRequested : The user clicks \"retry\". Effect CreateAccount(username, password) : The Update function tries to create an account using an effect again. Event AccountCreationSucceeded : Delayed response from the first attempt finally arrives. Event DuplicateUsernameError : Response from the second attempt. This gets tricky! Especially if the CreateAccount Effect Handler is implemented in such a way it no longer listens to the response from the first attempt after the timeout. In that scenario, the user\u2019s account has in fact been created, but there is no way to allow them to proceed to the next step since the client\u2019s business logic doesn\u2019t know this. This is in fact even more complicated, because the AccountCreationSucceeded response might get lost entirely \u2013 a real solution entails making the CreateAccount messages idempotent and some way for the backend to detect that two CreateAccount messages are in fact duplicates and not submitted by different users more or less concurrently. Mobius provides test tools ( see UpdateSpec.When ) that help you write test cases that validate the behaviour of your loop when a sequence of Events happen given an initial Model. This, combined with the sequential Event processing, helps you write robust code in a concurrent setting where Event ordering cannot be guaranteed.","title":"Objectives"},{"location":"objectives/#objectives","text":"Mobius was designed with some specific objectives in mind, and it\u2019s going to be easier both to use it correctly and to understand some of the design decisions if you know the underlying thinking. The original objectives we set out to achieve were: Strong separation of concerns in general, and specifically between presentation logic and business logic. Encourage maximal use of pure functions . Great testability through the design itself as well as included tooling. Ease of understanding systems' behaviour in terms of concurrency and ordering . The next couple of sections describe how Mobius achieves those objectives.","title":"Objectives"},{"location":"objectives/#separation-of-concerns","text":"Mobius ensures or encourages separation in the following ways: Separating what should happen from how it happens . Effects are requested by the Update function, and performed by Effect handlers. Separating handling of different kinds of Effect from one another . Through making it easy and recommended to implement individual Effect handlers for each Effect. Clarifying that UI state is different from loop state (the current Model) . Most of the UI state will be derivable from the loop state/Model, but not all of it. Examples of the latter include things like the current position in a text field, the current state of animation (usually) , etc. It\u2019s perfectly OK to have state in the UI, but you maximise the benefit you get from Mobius by minimising that state. Processing of Events happens sequentially, one Event at the time . This means that there can be no data races in the Update function. However, note that Mobius doesn't provide any guarantees at all about Event or Effect ordering, and we strongly recommend that you ensure that your Update functions are robust in the face of out-of-expected-order Events (strictly speaking, since there are no ordering guarantees, there can be no out-of-order Events).","title":"Separation of Concerns"},{"location":"objectives/#pure-functions","text":"Mutable state makes programs hard to understand, because it introduces the notion of change over time. To understand how something behaves, you must understand what has happened before so you can know the current state of the object. Pure functions, on the other hand, are predictable, making them easier to understand and test because their behaviour is entirely defined by their inputs. But mutable state is necessary in any interesting program. Mobius restricts mutable state to the following places, allowing you to implement the rest of the code as pure functions: In the UI : Most UI frameworks have lots of mutable state, such as the contents of or cursor position in a text field, the current state of an animation, etc. This state is separate from the Model, which holds the business logic state. Internals of MobiusLoop . The Model object must be immutable, but to support changing the internal state of the loop, Mobius tracks a reference to the current Model. As a user, you don\u2019t need to worry about this, because your Update and Init functions are pure functions. Persistent or feature-external state , such as the \u2018recent searches\u2019 history tracked by a Search feature, or the state of a Spotify user\u2019s playlists. A change to this type of state is made using an Effect that describes the desired change, and an Effect Handler that executes the actual change.","title":"Pure Functions"},{"location":"objectives/#testability","text":"We believe having a great set of tests for your code is one of the best ways to ensure you can be productive when coding, because great tests quickly give you feedback about mistakes made when you evolve your code. Great tests are characterised by: Short run times to get quick feedback cycles - subsecond is ideal. Small scope for errors => more precise reporting of what's broken. When something breaks, it should be obvious where in the system it broke. Sufficient coverage of branches and lines. Loose coupling with production code. Tests that use a lot of mocks and other ways of verifying that the system under test had side effects tend to be closely tied to the production code. It is better to write tests as \"Given an initial state, When X happens, Then the state is Y\" - rather than, \"Then method A on collaborator B was invoked with parameters C and D\". Adhering to the Single Responsibility principle - a test should have only one reason to change and/or fail. Violating the SRP for tests is a thing that greatly reduces evolvability of the system, because intended changes to production code lead to lots of unrelated changes to test code. The test code becomes a dead weight you have to drag around. Mobius helps to achieve these kinds of tests through: Pure functions that make it easy to get great coverage. They have no state-space, so less combinatorial explosion internally. Pure functions that make it unnecessary to verify side effects through mocks and spies. Strong separation of concerns that enables writing small tests (in the sense of how much production code a test covers). Small tests are faster and more precise, and more likely to have a single responsibility. Testing utilities ( see UpdateSpec and InitSpec especially) that make it convenient to write good outside-in tests. A recommended workflow that includes writing business logic tests before implementing it. This helps ensure there is no coupling with the production code - since it hasn\u2019t been written yet, it\u2019s not possible to couple your tests to it.","title":"Testability"},{"location":"objectives/#concurrency-and-ordering","text":"It is notoriously hard to write robust code when things can happen in any order, and in mobile apps, changes can come from the user, the system, or a backend service with no way of effectively controlling ordering. The first property of Mobius that helps make understanding a loop's behaviour is the sequential and atomic Event processing. Since the only thing that can change the loop\u2019s state is an Event arriving, and only one Event is processed at a given time, there are no data races in the loop itself. In contrast, a multi-threaded solution where a click listener might be modifying some mutable state concurrently with a response from backend server gets harder to understand. Second, since all Events and Effects are simple value objects, the history of processed Events and resulting Models and Effects provides excellent troubleshooting information. Mobius provides no guarantees about the execution order of Effects or arrival order of Events. The reason is that that\u2019s what the world is like, when you\u2019re doing distributed computing. You never know what\u2019s going to happen to requests you send somewhere else. So if you send a request from a client to some backend server, and you don\u2019t get a response, that could be caused by any of the following: The request got lost somewhere The response got lost somewhere The request or response is still en route and a response will arrive if you just wait \u2018a little longer\u2019 An implication of that is that if you send two requests from a client to a backend service, you don\u2019t know that the responses will arrive in the same order as the requests were sent. So in Mobius, we recommend that you ensure that your business logic can handle Events arriving in any order in a robust way. An example that shows some of the complexity is a signup process where the following happens: Event SignupRequested : The user clicks \"register\". Effect CreateAccount(username, password) : The Update function tries to create an account using an effect. Event AccountCreationTimedOut() : The Effect Handler decides a response is unlikely to happen. Event SignupRequested : The user clicks \"retry\". Effect CreateAccount(username, password) : The Update function tries to create an account using an effect again. Event AccountCreationSucceeded : Delayed response from the first attempt finally arrives. Event DuplicateUsernameError : Response from the second attempt. This gets tricky! Especially if the CreateAccount Effect Handler is implemented in such a way it no longer listens to the response from the first attempt after the timeout. In that scenario, the user\u2019s account has in fact been created, but there is no way to allow them to proceed to the next step since the client\u2019s business logic doesn\u2019t know this. This is in fact even more complicated, because the AccountCreationSucceeded response might get lost entirely \u2013 a real solution entails making the CreateAccount messages idempotent and some way for the backend to detect that two CreateAccount messages are in fact duplicates and not submitted by different users more or less concurrently. Mobius provides test tools ( see UpdateSpec.When ) that help you write test cases that validate the behaviour of your loop when a sequence of Events happen given an initial Model. This, combined with the sequential Event processing, helps you write robust code in a concurrent setting where Event ordering cannot be guaranteed.","title":"Concurrency and Ordering"},{"location":"prior-art/","text":"Prior Art \u00b6 Many readers may feel like Mobius is \"just like X\" - and they are correct. Here's a collection of related concepts, tools and frameworks that we're aware of and some of which we have used when coming up with Mobius. Being aware of our biases, we don't want to try to make comparisons, but in general, the main difference between Mobius and many of these alternatives is usually one of: Mobius Update functions return Effects as immutable descriptions of things that should happen rather than doing them directly or returning something that knows how to execute them. Mobius Update functions decide atomically which Effects and state changes should happen for a given Event. Contrasting this with the common approach in redux-like frameworks, there is no ordering between (in, say, RxRedux when a SideEffect processes an Action (potentially leading to new Actions) and when the Reducer will do it. The Mobius approach makes it easier to handle races. Mobius targets development in JVM/Android. Mobius is a framework that encodes its ideas in a way that is less subject to interpretation than a more loosely defined pattern is. Here's an unordered and incomplete list of related technologies, documents, talks and ideas that we are aware of: The Elm Architecture Haskell's State Monad Andy Matuschak's state machines Rx Workflows and also open-sourced Unidirectional UI architectures Cycle.js Redux Managing State with RxJava MVI RxRedux Grox Presenter First - similar to the Mobius Workflow .","title":"Prior Art"},{"location":"prior-art/#prior-art","text":"Many readers may feel like Mobius is \"just like X\" - and they are correct. Here's a collection of related concepts, tools and frameworks that we're aware of and some of which we have used when coming up with Mobius. Being aware of our biases, we don't want to try to make comparisons, but in general, the main difference between Mobius and many of these alternatives is usually one of: Mobius Update functions return Effects as immutable descriptions of things that should happen rather than doing them directly or returning something that knows how to execute them. Mobius Update functions decide atomically which Effects and state changes should happen for a given Event. Contrasting this with the common approach in redux-like frameworks, there is no ordering between (in, say, RxRedux when a SideEffect processes an Action (potentially leading to new Actions) and when the Reducer will do it. The Mobius approach makes it easier to handle races. Mobius targets development in JVM/Android. Mobius is a framework that encodes its ideas in a way that is less subject to interpretation than a more loosely defined pattern is. Here's an unordered and incomplete list of related technologies, documents, talks and ideas that we are aware of: The Elm Architecture Haskell's State Monad Andy Matuschak's state machines Rx Workflows and also open-sourced Unidirectional UI architectures Cycle.js Redux Managing State with RxJava MVI RxRedux Grox Presenter First - similar to the Mobius Workflow .","title":"Prior Art"},{"location":"the-mobius-workflow/","text":"The Mobius Workflow \u00b6 While developing the Mobius framework, we often found ourselves using real problems as examples when teaching how to use Mobius. After a while, we noticed that we always used the same structure to model the problems and, as a consequence, everyone in the team got a better understanding of what they were trying to solve and many edge-cases were discovered early on. A couple of teams started using this process as a tool to explore requirements early on in the project and use the findings to plan what to do, and their efforts have been successful. We call this process the Mobius workflow, and it\u2019s the recommended approach when planning and designing Mobius loops. Furthermore, it is recommended to take this approach as a team and involve everyone with different backgrounds. Through this collaboration on requirements discovery and planning, everyone on team ends up with a shared understanding and clarity on what the desired outcome is and since the output is directly translatable into a Mobius implementation, no details are lost in translation. Moreover, collaborative modeling enables the team to uncover edge-cases and specify how those should be dealt with. Step 1: Model it (a.k.a MoFlow) \u00b6 When defining your Mobius Update function, start by determining what it'll describe. Consider Init/Update functions as a behavior specification for your program. In order to articulate this behavior, you need to: Establish a lexicon that can be used to describe your behavior accurately Create the model that describes your program\u2019s state We\u2019ve found that this step is usually most efficient when people from different disciplines participate. Doing this first step in a group setting using a whiteboard helps the team figure out all the required events for their particular domain. As previously mentioned, Events in Mobius can be used to represent: User Interactions Effects Feedback External Events These event categories can be used as a guide for establishing the necessary constructs of a Mobius program. Define external events \u00b6 Start by identifying external events that provide you with necessary information about the environment your program is running in. For example, it must have internet connectivity to be able to load data from backend. Therefore, you can start by adding an event that notifies your update function of internet connectivity changes. Events Model Effects InternetStateChanged Capture user interactions \u00b6 Next you should define user interaction events. Think button taps, navigation, and user input. Take a close look at the designs you have and add an event for every interaction that a user can have with your app. For example, in our login loop a user can input their email and password, they can also tap the Login button and they can choose to navigate to the restore password screen. Events Model Effects InternetStateChanged EmailInputChanged PasswordInputChanged LoginButtonClicked ForgotPasswordClicked Define effects \u00b6 At this point, you\u2019ll start to see some effects that you would like to have as a result of the user interacting with your program. Add these effects to the effects column. In the login example, whenever the user clicks on the login button, the program is supposed to attempt logging in. Whenever the user clicks on the forgot password button, a restore password screen is supposed to appear. Events Model Effects InternetStateChanged AttemptLogin EmailInputChanged ShowRestorePasswordScreen PasswordInputChanged LoginButtonClicked ForgotPasswordClicked Define your model \u00b6 By this point, you have defined a set of events and effects. However, in most cases, events cannot directly result in effects and that is why your Update function takes two arguments; the current model and the event. Your model should represent the state of your feature. It should contain all the information necessary to help you make decisions about whether to dispatch effects and what the next state of your system should be. In our example, we see that in order to log in: It is necessary to be online. It is necessary to have an email and a password. It is necessary to keep track of whether there\u2019s a login attempt in progress to avoid unnecessary further attempts until the current attempt has completed. Furthermore, this piece of information can be used to inform the user about the login attempt in progress. Finally, it is desirable that the login button is only enabled when there is a valid email and password, so we need to keep track of that in our model as well Events Model Effects InternetStateChanged online? email password loggingIn? canLogin? AttemptLogin EmailInputChanged ShowRestorePasswordScreen PasswordInputChanged LoginButtonClicked ForgotPasswordClicked Define effects feedback events \u00b6 Once you have the model structure that will allow you to make decisions about dispatching effects in place, you can move on to defining the third kind of events: effect feedback (note that not all effects must necessarily generate feedback events). In our example, we see that of the two effects we have defined, only the AttemptLogin effect could generate feedback events: LoginSuccessful and LoginFailed. Events Model Effects InternetStateChanged online? email password loggingIn? canLogin? AttemptLogin EmailInputChanged ShowRestorePasswordScreen PasswordInputChanged LoginButtonClicked ForgotPasswordClicked LoginSuccessful LoginFailed Each time you add events, you should go back to the Effect definition step until you\u2019ve defined all events and effects for your domain and expanded your model to contain the required information for processing all events and dispatching all effects. In our example, we see that we can add a couple of more effects to respond to the LoginSuccessful and LoginFailed events. Events Model Effects InternetStateChanged online? email password loggingIn? canLogin? AttemptLogin EmailInputChanged ShowRestorePasswordScreen PasswordInputChanged NavigateToHome LoginButtonClicked ShowErrorToast ForgotPasswordClicked LoginSuccessful LoginFailed Step 2: Describe it \u00b6 Now that you have established all the necessary details that are required to write your behavior specification, you can start building your Update function. Building an Update function comprises the following steps: Think of a scenario that your tests need to cover, eg. given that the user is offline when the login button is clicked then show an error message Create/modify your Event, Effect, and Model types @DataEnum interface Event_dataenum { // ... dataenum_case LoginButtonClicked (); // ... } @DataEnum interface Effect_dataenum { // ... dataenum_case ShowErrorToast ( String message ); // ... } @AutoValue static abstract class Model { // ... public abstract boolean connected (); // ... } Write tests for the scenario spec . given ( Model . builder () . connected ( false ) . build ()) . when ( Event . loginButtonClicked ()) . then ( assertThatNext ( hasEffect ( Effect . showErrorToast ( \"must be online to log in\" ) ))); Change the code in your Update function to make the new tests pass // ... if ( event . isLoginButtonClicked () &&! model . connected ()){ return dispatch ( effects ( Effect . showErrorToast ( \"must be online to log in\" ))); } // ... Repeat steps 1 through 4 until you\u2019ve exhausted all scenarios Think of some unlikely scenarios and write some more tests! This step is really about solidifying what you\u2019ve captured in the first step. It\u2019ll also help you find out if you\u2019ve missed certain behaviors or if some behaviors conflict with others. It also helps you validate the completeness of your model. Once you\u2019re done writing your tests and Update function, you would have described in detail how your program will behave and answered all unknown questions early on. This step usually doesn\u2019t take more than a day since it is relatively easy to write Update functions thanks to their pure nature. Step 3: Plan it \u00b6 Now that you\u2019ve defined your Events, Effects, Model and Update, you can use this information to derive tasks that describe what work needs to be done for your project. You\u2019ll notice that most of the things that you need to build will produce one or more of the Events that you\u2019ve defined. We recommend that you cross-check your list of events and determine what components you need to build to produce these events. The idea is to define tasks for building the blocks that interact with your Update function. Event sources \u00b6 Start with your EventSources which provide your external events. In our example, we had only one event that is categorized as external: InternetStateChanged. So we know that we\u2019ll have to add a task for building that EventSource. Effects and their feedback events \u00b6 Once you\u2019ve created tasks for the external event sources, move on to Effects. We\u2019ve found that it is best to create an effect handler per effect. Create a task for each of your effects and associate their feedback events with that task. User interaction events \u00b6 This is where you start breaking up your UI into tasks. If your UI is simple, you could potentially have only one task for building it. However, for complex UIs we recommend dividing them into smaller pieces and associating events with each of these pieces. Now that you\u2019ve defined your different tasks, you can group them together to create user stories that you can add to your project tracking tool. This process works whether you use Scrum, Kanban or any other agile (or even waterfall) process framework since it produces a list of the work that needs to happen, but it lets you decide how to manage the building process the way you like. Furthermore, you can use the tasks that you\u2019ve made to identify dependencies you may have on other work that needs to be dealt with before you start. Step 4: Build it \u00b6 Time to write some more code! Check out the getting started guide for examples on how to build effect handlers and connect your UI to Mobius.","title":"Mobius Workflow"},{"location":"the-mobius-workflow/#the-mobius-workflow","text":"While developing the Mobius framework, we often found ourselves using real problems as examples when teaching how to use Mobius. After a while, we noticed that we always used the same structure to model the problems and, as a consequence, everyone in the team got a better understanding of what they were trying to solve and many edge-cases were discovered early on. A couple of teams started using this process as a tool to explore requirements early on in the project and use the findings to plan what to do, and their efforts have been successful. We call this process the Mobius workflow, and it\u2019s the recommended approach when planning and designing Mobius loops. Furthermore, it is recommended to take this approach as a team and involve everyone with different backgrounds. Through this collaboration on requirements discovery and planning, everyone on team ends up with a shared understanding and clarity on what the desired outcome is and since the output is directly translatable into a Mobius implementation, no details are lost in translation. Moreover, collaborative modeling enables the team to uncover edge-cases and specify how those should be dealt with.","title":"The Mobius Workflow"},{"location":"the-mobius-workflow/#step-1-model-it-aka-moflow","text":"When defining your Mobius Update function, start by determining what it'll describe. Consider Init/Update functions as a behavior specification for your program. In order to articulate this behavior, you need to: Establish a lexicon that can be used to describe your behavior accurately Create the model that describes your program\u2019s state We\u2019ve found that this step is usually most efficient when people from different disciplines participate. Doing this first step in a group setting using a whiteboard helps the team figure out all the required events for their particular domain. As previously mentioned, Events in Mobius can be used to represent: User Interactions Effects Feedback External Events These event categories can be used as a guide for establishing the necessary constructs of a Mobius program.","title":"Step 1: Model it (a.k.a MoFlow)"},{"location":"the-mobius-workflow/#define-external-events","text":"Start by identifying external events that provide you with necessary information about the environment your program is running in. For example, it must have internet connectivity to be able to load data from backend. Therefore, you can start by adding an event that notifies your update function of internet connectivity changes. Events Model Effects InternetStateChanged","title":"Define external events"},{"location":"the-mobius-workflow/#capture-user-interactions","text":"Next you should define user interaction events. Think button taps, navigation, and user input. Take a close look at the designs you have and add an event for every interaction that a user can have with your app. For example, in our login loop a user can input their email and password, they can also tap the Login button and they can choose to navigate to the restore password screen. Events Model Effects InternetStateChanged EmailInputChanged PasswordInputChanged LoginButtonClicked ForgotPasswordClicked","title":"Capture user interactions"},{"location":"the-mobius-workflow/#define-effects","text":"At this point, you\u2019ll start to see some effects that you would like to have as a result of the user interacting with your program. Add these effects to the effects column. In the login example, whenever the user clicks on the login button, the program is supposed to attempt logging in. Whenever the user clicks on the forgot password button, a restore password screen is supposed to appear. Events Model Effects InternetStateChanged AttemptLogin EmailInputChanged ShowRestorePasswordScreen PasswordInputChanged LoginButtonClicked ForgotPasswordClicked","title":"Define effects"},{"location":"the-mobius-workflow/#define-your-model","text":"By this point, you have defined a set of events and effects. However, in most cases, events cannot directly result in effects and that is why your Update function takes two arguments; the current model and the event. Your model should represent the state of your feature. It should contain all the information necessary to help you make decisions about whether to dispatch effects and what the next state of your system should be. In our example, we see that in order to log in: It is necessary to be online. It is necessary to have an email and a password. It is necessary to keep track of whether there\u2019s a login attempt in progress to avoid unnecessary further attempts until the current attempt has completed. Furthermore, this piece of information can be used to inform the user about the login attempt in progress. Finally, it is desirable that the login button is only enabled when there is a valid email and password, so we need to keep track of that in our model as well Events Model Effects InternetStateChanged online? email password loggingIn? canLogin? AttemptLogin EmailInputChanged ShowRestorePasswordScreen PasswordInputChanged LoginButtonClicked ForgotPasswordClicked","title":"Define your model"},{"location":"the-mobius-workflow/#define-effects-feedback-events","text":"Once you have the model structure that will allow you to make decisions about dispatching effects in place, you can move on to defining the third kind of events: effect feedback (note that not all effects must necessarily generate feedback events). In our example, we see that of the two effects we have defined, only the AttemptLogin effect could generate feedback events: LoginSuccessful and LoginFailed. Events Model Effects InternetStateChanged online? email password loggingIn? canLogin? AttemptLogin EmailInputChanged ShowRestorePasswordScreen PasswordInputChanged LoginButtonClicked ForgotPasswordClicked LoginSuccessful LoginFailed Each time you add events, you should go back to the Effect definition step until you\u2019ve defined all events and effects for your domain and expanded your model to contain the required information for processing all events and dispatching all effects. In our example, we see that we can add a couple of more effects to respond to the LoginSuccessful and LoginFailed events. Events Model Effects InternetStateChanged online? email password loggingIn? canLogin? AttemptLogin EmailInputChanged ShowRestorePasswordScreen PasswordInputChanged NavigateToHome LoginButtonClicked ShowErrorToast ForgotPasswordClicked LoginSuccessful LoginFailed","title":"Define effects feedback events"},{"location":"the-mobius-workflow/#step-2-describe-it","text":"Now that you have established all the necessary details that are required to write your behavior specification, you can start building your Update function. Building an Update function comprises the following steps: Think of a scenario that your tests need to cover, eg. given that the user is offline when the login button is clicked then show an error message Create/modify your Event, Effect, and Model types @DataEnum interface Event_dataenum { // ... dataenum_case LoginButtonClicked (); // ... } @DataEnum interface Effect_dataenum { // ... dataenum_case ShowErrorToast ( String message ); // ... } @AutoValue static abstract class Model { // ... public abstract boolean connected (); // ... } Write tests for the scenario spec . given ( Model . builder () . connected ( false ) . build ()) . when ( Event . loginButtonClicked ()) . then ( assertThatNext ( hasEffect ( Effect . showErrorToast ( \"must be online to log in\" ) ))); Change the code in your Update function to make the new tests pass // ... if ( event . isLoginButtonClicked () &&! model . connected ()){ return dispatch ( effects ( Effect . showErrorToast ( \"must be online to log in\" ))); } // ... Repeat steps 1 through 4 until you\u2019ve exhausted all scenarios Think of some unlikely scenarios and write some more tests! This step is really about solidifying what you\u2019ve captured in the first step. It\u2019ll also help you find out if you\u2019ve missed certain behaviors or if some behaviors conflict with others. It also helps you validate the completeness of your model. Once you\u2019re done writing your tests and Update function, you would have described in detail how your program will behave and answered all unknown questions early on. This step usually doesn\u2019t take more than a day since it is relatively easy to write Update functions thanks to their pure nature.","title":"Step 2: Describe it"},{"location":"the-mobius-workflow/#step-3-plan-it","text":"Now that you\u2019ve defined your Events, Effects, Model and Update, you can use this information to derive tasks that describe what work needs to be done for your project. You\u2019ll notice that most of the things that you need to build will produce one or more of the Events that you\u2019ve defined. We recommend that you cross-check your list of events and determine what components you need to build to produce these events. The idea is to define tasks for building the blocks that interact with your Update function.","title":"Step 3: Plan it"},{"location":"the-mobius-workflow/#event-sources","text":"Start with your EventSources which provide your external events. In our example, we had only one event that is categorized as external: InternetStateChanged. So we know that we\u2019ll have to add a task for building that EventSource.","title":"Event sources"},{"location":"the-mobius-workflow/#effects-and-their-feedback-events","text":"Once you\u2019ve created tasks for the external event sources, move on to Effects. We\u2019ve found that it is best to create an effect handler per effect. Create a task for each of your effects and associate their feedback events with that task.","title":"Effects and their feedback events"},{"location":"the-mobius-workflow/#user-interaction-events","text":"This is where you start breaking up your UI into tasks. If your UI is simple, you could potentially have only one task for building it. However, for complex UIs we recommend dividing them into smaller pieces and associating events with each of these pieces. Now that you\u2019ve defined your different tasks, you can group them together to create user stories that you can add to your project tracking tool. This process works whether you use Scrum, Kanban or any other agile (or even waterfall) process framework since it produces a list of the work that needs to happen, but it lets you decide how to manage the building process the way you like. Furthermore, you can use the tasks that you\u2019ve made to identify dependencies you may have on other work that needs to be dealt with before you start.","title":"User interaction events"},{"location":"the-mobius-workflow/#step-4-build-it","text":"Time to write some more code! Check out the getting started guide for examples on how to build effect handlers and connect your UI to Mobius.","title":"Step 4: Build it"},{"location":"getting-started/configuring-a-mobius-loop/","text":"Configuring a MobiusLoop \u00b6 So far, we\u2019ve started the loop in the following manner: MobiusLoop < Model , Event , Effect > loop = Mobius . loop ( Example :: update , effectHandler ) . startFrom ( 2 ); This means providing only the mandatory parameters (an Update function and an Effect handler) of a MobiusLoop , and using default values for the rest. This section describes what the optional parameters are and how to configure them. Previously, we've immediately started the loop by the call to startFrom(...) . If we don't call it, we instead get a MobiusLoop.Builder<M, E, F> : MobiusLoop . Builder < Integer , Event , Effect > loopBuilder = Mobius . loop ( Example :: update , Example :: effectHandler ); ( RxMobius.loop() also returns a MobiusLoop.Builder<M, E, F> ) The builder enables us to configure the loop before we start it. It's an immutable object, so it's therefore safe to share and reuse it to start several loops from the same configuration. If you pass it around as a dependency, consider upcasting it to MobiusLoop.Factory , which is the interface that contains only startFrom(...) . This enables dependents to start new loops but not create new configurations based on the old one. Here's what you can configure in MobiusLoop.Builder - details of each item are described below: MobiusLoop < Model , Event , Effect > loop = Mobius . loop ( Example :: update , effectHandler ) . init ( Example :: init ) . eventSource ( Example :: externalEvents ) . eventRunner ( WorkRunners . singleThread ()) . effectRunner ( WorkRunners . fixedThreadPool ( 2 )) . logger ( SLF4JLogger . withTag ( \"Example Loop\" )) . startFrom ( Model . createDefault ()); init(...) \u00b6 NOTE: deprecated; prefer using either the MobiusController, or startFrom(model, effects) instead. An init function resembles an update function, but it is only executed once when the loop starts ( read in the concepts guide about init for details on why you might want to have an init function). The differences to update is that the init function doesn't get any event (you could say there is an implicit \"the loop is starting\" event) and that it returns a First instead of a Next. A First must contain a model, but apart from that the two classes are the same. eventSource(...) \u00b6 The EventSource of your program is supposed to be used for external events (see Events in depth for more details). If you have multiple external event sources, they must be merged into a single EventSource before being hooked with with Mobius. Consider an event source as an effect handler without incoming effect objects and that it just emits events on its own. Basically an event source lets the loop listen to external signals, for example network connectivity changes or timer ticks. UI events should not be sent to the loop via the event source, but instead from the outside of the loop through MobiusLoop.dispatchEvent() . It is possible to send UI events through an event source, and once an event reaches the update function there is no difference between the origins of the events. However avoid sending UI events through the event source, as it is intended for external events only. You must be careful if you implement the EventSource interface directly. It has the same requirements as effect handlers, that is, it must release resources and stop emitting events when it is disposed (see the javadocs on EventSource for details). In most cases you should instead use RxEventSources which takes care of all that for you. logger(...) \u00b6 The MobiusLoop.Logger interface enables you to inspect what the init and update functions are doing. Every event, effect, and model change in the loop will go through the logger, so if there are any issues with your loop, the logs tells you what state the loop was in when the problem happened, and how it got there. Because of the usefulness of loggers, we recommended that you always set one in debug builds. Mobius provides two implementations of Logger: SLF4JLogger in mobius-extras and AndroidLogger in mobius-android. eventRunner(...) / effectRunner(...) \u00b6 Mobius uses WorkRunner s to execute work on different threads. A MobiusLoop has two of these internally: one for events ( for example, the thread that runs the update function) and one for effects (for example, the thread that sends effects to the effect handler). Since the builder can be used to start multiple loops, you will have to pass WorkRunner factories to the builder. Usually you don't need to override this, but it can be useful in integration tests to use WorkRunners.immediate() in order to make MobiusLoop synchronous. Other than the work runners in the WorkRunners class, there is also a SchedulerWorkRunner in mobius-rx/mobius-rx2.","title":"Configuring a MobiusLoop"},{"location":"getting-started/configuring-a-mobius-loop/#configuring-a-mobiusloop","text":"So far, we\u2019ve started the loop in the following manner: MobiusLoop < Model , Event , Effect > loop = Mobius . loop ( Example :: update , effectHandler ) . startFrom ( 2 ); This means providing only the mandatory parameters (an Update function and an Effect handler) of a MobiusLoop , and using default values for the rest. This section describes what the optional parameters are and how to configure them. Previously, we've immediately started the loop by the call to startFrom(...) . If we don't call it, we instead get a MobiusLoop.Builder<M, E, F> : MobiusLoop . Builder < Integer , Event , Effect > loopBuilder = Mobius . loop ( Example :: update , Example :: effectHandler ); ( RxMobius.loop() also returns a MobiusLoop.Builder<M, E, F> ) The builder enables us to configure the loop before we start it. It's an immutable object, so it's therefore safe to share and reuse it to start several loops from the same configuration. If you pass it around as a dependency, consider upcasting it to MobiusLoop.Factory , which is the interface that contains only startFrom(...) . This enables dependents to start new loops but not create new configurations based on the old one. Here's what you can configure in MobiusLoop.Builder - details of each item are described below: MobiusLoop < Model , Event , Effect > loop = Mobius . loop ( Example :: update , effectHandler ) . init ( Example :: init ) . eventSource ( Example :: externalEvents ) . eventRunner ( WorkRunners . singleThread ()) . effectRunner ( WorkRunners . fixedThreadPool ( 2 )) . logger ( SLF4JLogger . withTag ( \"Example Loop\" )) . startFrom ( Model . createDefault ());","title":"Configuring a MobiusLoop"},{"location":"getting-started/configuring-a-mobius-loop/#init","text":"NOTE: deprecated; prefer using either the MobiusController, or startFrom(model, effects) instead. An init function resembles an update function, but it is only executed once when the loop starts ( read in the concepts guide about init for details on why you might want to have an init function). The differences to update is that the init function doesn't get any event (you could say there is an implicit \"the loop is starting\" event) and that it returns a First instead of a Next. A First must contain a model, but apart from that the two classes are the same.","title":"init(...)"},{"location":"getting-started/configuring-a-mobius-loop/#eventsource","text":"The EventSource of your program is supposed to be used for external events (see Events in depth for more details). If you have multiple external event sources, they must be merged into a single EventSource before being hooked with with Mobius. Consider an event source as an effect handler without incoming effect objects and that it just emits events on its own. Basically an event source lets the loop listen to external signals, for example network connectivity changes or timer ticks. UI events should not be sent to the loop via the event source, but instead from the outside of the loop through MobiusLoop.dispatchEvent() . It is possible to send UI events through an event source, and once an event reaches the update function there is no difference between the origins of the events. However avoid sending UI events through the event source, as it is intended for external events only. You must be careful if you implement the EventSource interface directly. It has the same requirements as effect handlers, that is, it must release resources and stop emitting events when it is disposed (see the javadocs on EventSource for details). In most cases you should instead use RxEventSources which takes care of all that for you.","title":"eventSource(...)"},{"location":"getting-started/configuring-a-mobius-loop/#logger","text":"The MobiusLoop.Logger interface enables you to inspect what the init and update functions are doing. Every event, effect, and model change in the loop will go through the logger, so if there are any issues with your loop, the logs tells you what state the loop was in when the problem happened, and how it got there. Because of the usefulness of loggers, we recommended that you always set one in debug builds. Mobius provides two implementations of Logger: SLF4JLogger in mobius-extras and AndroidLogger in mobius-android.","title":"logger(...)"},{"location":"getting-started/configuring-a-mobius-loop/#eventrunner-effectrunner","text":"Mobius uses WorkRunner s to execute work on different threads. A MobiusLoop has two of these internally: one for events ( for example, the thread that runs the update function) and one for effects (for example, the thread that sends effects to the effect handler). Since the builder can be used to start multiple loops, you will have to pass WorkRunner factories to the builder. Usually you don't need to override this, but it can be useful in integration tests to use WorkRunners.immediate() in order to make MobiusLoop synchronous. Other than the work runners in the WorkRunners class, there is also a SchedulerWorkRunner in mobius-rx/mobius-rx2.","title":"eventRunner(...) / effectRunner(...)"},{"location":"getting-started/creating-a-loop/","text":"Creating a loop \u00b6 Let's build a simple \"hello world\" in Mobius. We'll create a simple counter that counts up or down when we send events to the loop. We need to keep track of the current value of the counter, so we'll be using an Integer as our model, and define an enum with events for increasing and decreasing the value: enum Event { UP , DOWN } When we get the up event, the counter should increase, and when we get the down event, it should decrease. To make the example slightly more interesting, let's say that you shouldn't be able to make the counter go negative. Let's write a simplified update function that describes this behaviour ('simplified' in the sense of not supporting Effects - we'll get back to that later!): static int update ( int counter , Event event ) { switch ( event ) { case UP : return counter + 1 ; case DOWN : if ( counter > 0 ) { return counter - 1 ; } return counter ; } } We are now ready to create the simplified loop: MobiusLoop < Integer , Event , ?> loop = MobiusExtras . beginnerLoop ( Example :: update ) . startFrom ( 2 ); This creates a loop that starts the counter at 2. Before sending events to the loop, we need to add an observer , so that we can see how the counter changes: loop . observe ( counter -> System . out . println ( counter )); Observers always receive the most recent state when they are added, so this line of code causes the current value of the counter to be printed: \"2\". Now we are ready to send events! Let's put in a bunch of UPs and DOWNs and see what happens: loop . dispatchEvent ( DOWN ); // prints \"1\" loop . dispatchEvent ( DOWN ); // prints \"0\" loop . dispatchEvent ( DOWN ); // prints \"0\" loop . dispatchEvent ( UP ); // prints \"1\" loop . dispatchEvent ( UP ); // prints \"2\" loop . dispatchEvent ( DOWN ); // prints \"1\" Finally, you always want to clean up after yourself: loop . dispose (); Adding Effects \u00b6 One of Mobius\u2019s strengths is its declarative style of describing side-effects, however in our first example we had a simplified update function that didn't use any effects. Let\u2019s expand it to show how you dispatch and handle an effect. Let's say that we want to keep disallowing negative numbers for the counter, but now if someone tries to decrease the number to less than zero, the counter is supposed to print an error message as a side-effect. First we need to create a type for the effects. We only have one effect right now, but let's use an enum anyway, like we did with the events: enum Effect { REPORT_ERROR_NEGATIVE } The update function is the only thing in Mobius that triggers effects, so we need to change the signature so that it can tell us that an effect is supposed to happen. In Mobius, the Next<M, F> class (many Mobius types are parameterised with one or more of M , E , and F , for Model, Event and Effect respectively) is utilized to dispatch effects and apply changes to the model. Let's start by changing the return type of the update function. The int we have used to keep track of the current value of the counter is usually referred to as the model object in Mobius, so we change that name too. static Next < Integer , Effect > update ( int model , Event event ) { switch ( event ) { case UP : return Next . next ( model + 1 ); case DOWN : if ( counter > 0 ) { return Next . next ( model - 1 ); } return Next . next ( model ); } } Consider Next to be an object that describes \"what should happen next\". Therefore, the complete update function describes: \"given a certain model and an event, what should happen next?\" This is what we mean when we say that the code in the update function is declarative: the update function only declares what is supposed to occur, but it doesn't make it occur. Let's now change the less-than-zero case so that instead of returning the current model, it declares that an error should be reported: static Next < Integer , Effect > update ( int model , Event event ) { switch ( event ) { case UP : return Next . next ( model + 1 ); case DOWN : if ( counter > 0 ) { return Next . next ( model - 1 ); } return Next . next ( model , Effects . effects ( REPORT_ERROR_NEGATIVE )); } } For the sake of readability you should statically import the methods on Next and Effects, so let's go ahead and do that: static Next < Integer , Effect > update ( int model , Event event ) { switch ( event ) { case UP : return next ( model + 1 ); case DOWN : if ( counter > 0 ) { return next ( model - 1 ); } return next ( model , effects ( REPORT_ERROR_NEGATIVE )); } } That's it for the update function! Since we now have an effect, we need an Effect handler. When an Update function dispatches Effects, Mobius will automatically forward them to the Effect handler. It executes the Effects, making the declared things happen. An Effect Handler can be thought of as a loop segment that connects the Effect-dispatching part of the Update function with the Event-receiving part. An Effect Handler is a function from a Consumer<Event> - the place where it should put generated Events - to a Connection<Effect> - the place where Mobius should put Effects, and where it can request shutdown. The basic shape looks like this: static Connection < Effect > effectHandler ( Consumer < Event > eventConsumer ) { return new Connection < Effect > () { @Override public void accept ( Effect effect ) { // ... } @Override public void dispose () { // ... } }; } If you're used to Observables , this may look backwards. It's because Mobius uses Consumers that you push things to rather than Observables that you receive things from. The effect handler gets connected to the loop by the framework when the loop starts. When connecting, the handler must create a new Connection that Mobius uses to send Effect objects to the Effect handler. The Event consumer is used for sending events back to the update function, however it is important that the handler respects the dispose() call. This means that when dispose() is called, no more events may be sent to the event consumer. Furthermore, any resources associated with the connection should be released when the connection gets disposed. In this case we have a very simple effect handler that doesn\u2019t emit any events and therefore ignores the eventConsumer : static Connection < Effect > effectHandler ( Consumer < Event > eventConsumer ) { return new Connection < Effect > () { @Override public void accept ( Effect effect ) { if ( effect == REPORT_ERROR_NEGATIVE ) { System . out . println ( \"error!\" ); } } @Override public void dispose () { // We don't have any resources to release, so we can leave this empty. } }; } Now, armed with our new update function and effect handler, we're ready to set up the loop again: MobiusLoop < Integer , Event , Effect > loop = Mobius . loop ( Example :: update , Example :: effectHandler ) . startFrom ( 2 ); loop . observe ( counter -> System . out . println ( counter )); Like last time it sets up the loop to start from \"2\", but this time with our new update function and an effect handler. Let's enter the same UP s and DOWN s as last time and see what happens: loop . dispatchEvent ( DOWN ); // prints \"1\" loop . dispatchEvent ( DOWN ); // prints \"0\" loop . dispatchEvent ( DOWN ); // prints \"0\", followed by \"error!\" loop . dispatchEvent ( UP ); // prints \"1\" loop . dispatchEvent ( UP ); // prints \"2\" loop . dispatchEvent ( DOWN ); // prints \"1\" It prints the new error message, and we see that it still prints a zero. However, we would like to get only the error message, and not the current value of the counter. Fortunately Next has the following four static factory methods: Model changed Model unchanged Effects Next.next(model, effects) Next.dispatch(effects) No Effects Next.next(model) Next.noChange() This enables us to say either that nothing should happen (no new model, no effects) or that we only want to dispatch some effects (no new model, but some effects). To do this you use Next.noChange() or Next.dispatch(effects(...)) respectively. We don't make any changes to the model in the less-than-zero case, so let's change the update function to use dispatch(effects(...)) : static Next < Integer , Effect > update ( int model , Event event ) { switch ( event ) { case UP : return next ( model + 1 ); case DOWN : if ( counter > 0 ) { return next ( model - 1 ); } return dispatch ( effects ( REPORT_ERROR_NEGATIVE )); } } Now let's send our events again: loop . dispatchEvent ( DOWN ); // prints \"1\" loop . dispatchEvent ( DOWN ); // prints \"0\" loop . dispatchEvent ( DOWN ); // prints \"error!\" loop . dispatchEvent ( UP ); // prints \"1\" loop . dispatchEvent ( UP ); // prints \"2\" loop . dispatchEvent ( DOWN ); // prints \"1\" Success! In this case we merely printed the error to the screen, but you can imagine the effect handler doing something more sophisticated, maybe flashing a light, playing a sound effect, or reporting the error to a server. Using DataEnum and AutoValue \u00b6 When using Mobius you usually want to use a bit more expressive type for out Model, Event, and Effect classes than just ints and enums. Our example with a counter is quite simple, so using more expressive types wouldn\u2019t really help making things easier to understand. Because the counter is a simple example, and because DataEnum (Algebraic data types for Java) and AutoValue (Immutable value types for Java) are recommended when defining Model, Events, and Effects, we\u2019ll modify the counter to show the basics of DataEnum and AutoValue usage. We start by defining our new Model, Event, and Effect types: @AutoValue public abstract class Model { public abstract int counter (); public Model increase () { return create ( counter () + 1 ); } public Model decrease () { return create ( counter () - 1 ); } public Model create ( int counter ) { return new AutoValue_Model ( counter ); } } @DataEnum interface Event_datenum { dataenum_case Up (); dataenum_case Down (); } @DataEnum interface Effect_datenum { dataenum_case ReportErrorNegative (); } Now let\u2019s change the update function and effect handler to use the new types: static Next < Model , Effect > update ( Model model , Event event ) { return event . map ( up -> { return next ( model . increase ()); }, down -> { if ( model . counter () > 0 ) { return next ( model . decrease ()); } return dispatch ( effects ( Effect . reportErrorNegative ())); } ); } static Connection < Effect > effectHandler ( Consumer < Event > eventConsumer ) { return new Connection < Effect > () { @Override public void accept ( Effect effect ) { // effect.match() is like event.map() but has no return value effect . match ( reportErrorNegative -> System . out . println ( \"error!\" ) ); } @Override public void dispose () { // No resources to release. } }; } In this effect handler, we just print an error message to standard out, which is about the simplest possible side-effect you can have. On top of that, we\u2019re only handling a single effect. A typical loop might contain many effects that need to be handled, and they are often asynchronous. On top of that, no further events may be emitted after dispose() is called, so if you have a lot of things going on here then it can get quite messy to deal with cleaning everything up. Luckily, asynchronicity and cleaning up is precisely what RxJava is good at! If you squint a bit, you might be able to tell that the effect handler resembles Observable transformers from RxJava. They are in fact compatible: the mobius-rx / mobius-rx2 modules contain utilities to convert to and from Observable transformers, so that you can use transformers as effect handlers. You\u2019ll get some examples of this in the next section .","title":"Creating a loop"},{"location":"getting-started/creating-a-loop/#creating-a-loop","text":"Let's build a simple \"hello world\" in Mobius. We'll create a simple counter that counts up or down when we send events to the loop. We need to keep track of the current value of the counter, so we'll be using an Integer as our model, and define an enum with events for increasing and decreasing the value: enum Event { UP , DOWN } When we get the up event, the counter should increase, and when we get the down event, it should decrease. To make the example slightly more interesting, let's say that you shouldn't be able to make the counter go negative. Let's write a simplified update function that describes this behaviour ('simplified' in the sense of not supporting Effects - we'll get back to that later!): static int update ( int counter , Event event ) { switch ( event ) { case UP : return counter + 1 ; case DOWN : if ( counter > 0 ) { return counter - 1 ; } return counter ; } } We are now ready to create the simplified loop: MobiusLoop < Integer , Event , ?> loop = MobiusExtras . beginnerLoop ( Example :: update ) . startFrom ( 2 ); This creates a loop that starts the counter at 2. Before sending events to the loop, we need to add an observer , so that we can see how the counter changes: loop . observe ( counter -> System . out . println ( counter )); Observers always receive the most recent state when they are added, so this line of code causes the current value of the counter to be printed: \"2\". Now we are ready to send events! Let's put in a bunch of UPs and DOWNs and see what happens: loop . dispatchEvent ( DOWN ); // prints \"1\" loop . dispatchEvent ( DOWN ); // prints \"0\" loop . dispatchEvent ( DOWN ); // prints \"0\" loop . dispatchEvent ( UP ); // prints \"1\" loop . dispatchEvent ( UP ); // prints \"2\" loop . dispatchEvent ( DOWN ); // prints \"1\" Finally, you always want to clean up after yourself: loop . dispose ();","title":"Creating a loop"},{"location":"getting-started/creating-a-loop/#adding-effects","text":"One of Mobius\u2019s strengths is its declarative style of describing side-effects, however in our first example we had a simplified update function that didn't use any effects. Let\u2019s expand it to show how you dispatch and handle an effect. Let's say that we want to keep disallowing negative numbers for the counter, but now if someone tries to decrease the number to less than zero, the counter is supposed to print an error message as a side-effect. First we need to create a type for the effects. We only have one effect right now, but let's use an enum anyway, like we did with the events: enum Effect { REPORT_ERROR_NEGATIVE } The update function is the only thing in Mobius that triggers effects, so we need to change the signature so that it can tell us that an effect is supposed to happen. In Mobius, the Next<M, F> class (many Mobius types are parameterised with one or more of M , E , and F , for Model, Event and Effect respectively) is utilized to dispatch effects and apply changes to the model. Let's start by changing the return type of the update function. The int we have used to keep track of the current value of the counter is usually referred to as the model object in Mobius, so we change that name too. static Next < Integer , Effect > update ( int model , Event event ) { switch ( event ) { case UP : return Next . next ( model + 1 ); case DOWN : if ( counter > 0 ) { return Next . next ( model - 1 ); } return Next . next ( model ); } } Consider Next to be an object that describes \"what should happen next\". Therefore, the complete update function describes: \"given a certain model and an event, what should happen next?\" This is what we mean when we say that the code in the update function is declarative: the update function only declares what is supposed to occur, but it doesn't make it occur. Let's now change the less-than-zero case so that instead of returning the current model, it declares that an error should be reported: static Next < Integer , Effect > update ( int model , Event event ) { switch ( event ) { case UP : return Next . next ( model + 1 ); case DOWN : if ( counter > 0 ) { return Next . next ( model - 1 ); } return Next . next ( model , Effects . effects ( REPORT_ERROR_NEGATIVE )); } } For the sake of readability you should statically import the methods on Next and Effects, so let's go ahead and do that: static Next < Integer , Effect > update ( int model , Event event ) { switch ( event ) { case UP : return next ( model + 1 ); case DOWN : if ( counter > 0 ) { return next ( model - 1 ); } return next ( model , effects ( REPORT_ERROR_NEGATIVE )); } } That's it for the update function! Since we now have an effect, we need an Effect handler. When an Update function dispatches Effects, Mobius will automatically forward them to the Effect handler. It executes the Effects, making the declared things happen. An Effect Handler can be thought of as a loop segment that connects the Effect-dispatching part of the Update function with the Event-receiving part. An Effect Handler is a function from a Consumer<Event> - the place where it should put generated Events - to a Connection<Effect> - the place where Mobius should put Effects, and where it can request shutdown. The basic shape looks like this: static Connection < Effect > effectHandler ( Consumer < Event > eventConsumer ) { return new Connection < Effect > () { @Override public void accept ( Effect effect ) { // ... } @Override public void dispose () { // ... } }; } If you're used to Observables , this may look backwards. It's because Mobius uses Consumers that you push things to rather than Observables that you receive things from. The effect handler gets connected to the loop by the framework when the loop starts. When connecting, the handler must create a new Connection that Mobius uses to send Effect objects to the Effect handler. The Event consumer is used for sending events back to the update function, however it is important that the handler respects the dispose() call. This means that when dispose() is called, no more events may be sent to the event consumer. Furthermore, any resources associated with the connection should be released when the connection gets disposed. In this case we have a very simple effect handler that doesn\u2019t emit any events and therefore ignores the eventConsumer : static Connection < Effect > effectHandler ( Consumer < Event > eventConsumer ) { return new Connection < Effect > () { @Override public void accept ( Effect effect ) { if ( effect == REPORT_ERROR_NEGATIVE ) { System . out . println ( \"error!\" ); } } @Override public void dispose () { // We don't have any resources to release, so we can leave this empty. } }; } Now, armed with our new update function and effect handler, we're ready to set up the loop again: MobiusLoop < Integer , Event , Effect > loop = Mobius . loop ( Example :: update , Example :: effectHandler ) . startFrom ( 2 ); loop . observe ( counter -> System . out . println ( counter )); Like last time it sets up the loop to start from \"2\", but this time with our new update function and an effect handler. Let's enter the same UP s and DOWN s as last time and see what happens: loop . dispatchEvent ( DOWN ); // prints \"1\" loop . dispatchEvent ( DOWN ); // prints \"0\" loop . dispatchEvent ( DOWN ); // prints \"0\", followed by \"error!\" loop . dispatchEvent ( UP ); // prints \"1\" loop . dispatchEvent ( UP ); // prints \"2\" loop . dispatchEvent ( DOWN ); // prints \"1\" It prints the new error message, and we see that it still prints a zero. However, we would like to get only the error message, and not the current value of the counter. Fortunately Next has the following four static factory methods: Model changed Model unchanged Effects Next.next(model, effects) Next.dispatch(effects) No Effects Next.next(model) Next.noChange() This enables us to say either that nothing should happen (no new model, no effects) or that we only want to dispatch some effects (no new model, but some effects). To do this you use Next.noChange() or Next.dispatch(effects(...)) respectively. We don't make any changes to the model in the less-than-zero case, so let's change the update function to use dispatch(effects(...)) : static Next < Integer , Effect > update ( int model , Event event ) { switch ( event ) { case UP : return next ( model + 1 ); case DOWN : if ( counter > 0 ) { return next ( model - 1 ); } return dispatch ( effects ( REPORT_ERROR_NEGATIVE )); } } Now let's send our events again: loop . dispatchEvent ( DOWN ); // prints \"1\" loop . dispatchEvent ( DOWN ); // prints \"0\" loop . dispatchEvent ( DOWN ); // prints \"error!\" loop . dispatchEvent ( UP ); // prints \"1\" loop . dispatchEvent ( UP ); // prints \"2\" loop . dispatchEvent ( DOWN ); // prints \"1\" Success! In this case we merely printed the error to the screen, but you can imagine the effect handler doing something more sophisticated, maybe flashing a light, playing a sound effect, or reporting the error to a server.","title":"Adding Effects"},{"location":"getting-started/creating-a-loop/#using-dataenum-and-autovalue","text":"When using Mobius you usually want to use a bit more expressive type for out Model, Event, and Effect classes than just ints and enums. Our example with a counter is quite simple, so using more expressive types wouldn\u2019t really help making things easier to understand. Because the counter is a simple example, and because DataEnum (Algebraic data types for Java) and AutoValue (Immutable value types for Java) are recommended when defining Model, Events, and Effects, we\u2019ll modify the counter to show the basics of DataEnum and AutoValue usage. We start by defining our new Model, Event, and Effect types: @AutoValue public abstract class Model { public abstract int counter (); public Model increase () { return create ( counter () + 1 ); } public Model decrease () { return create ( counter () - 1 ); } public Model create ( int counter ) { return new AutoValue_Model ( counter ); } } @DataEnum interface Event_datenum { dataenum_case Up (); dataenum_case Down (); } @DataEnum interface Effect_datenum { dataenum_case ReportErrorNegative (); } Now let\u2019s change the update function and effect handler to use the new types: static Next < Model , Effect > update ( Model model , Event event ) { return event . map ( up -> { return next ( model . increase ()); }, down -> { if ( model . counter () > 0 ) { return next ( model . decrease ()); } return dispatch ( effects ( Effect . reportErrorNegative ())); } ); } static Connection < Effect > effectHandler ( Consumer < Event > eventConsumer ) { return new Connection < Effect > () { @Override public void accept ( Effect effect ) { // effect.match() is like event.map() but has no return value effect . match ( reportErrorNegative -> System . out . println ( \"error!\" ) ); } @Override public void dispose () { // No resources to release. } }; } In this effect handler, we just print an error message to standard out, which is about the simplest possible side-effect you can have. On top of that, we\u2019re only handling a single effect. A typical loop might contain many effects that need to be handled, and they are often asynchronous. On top of that, no further events may be emitted after dispose() is called, so if you have a lot of things going on here then it can get quite messy to deal with cleaning everything up. Luckily, asynchronicity and cleaning up is precisely what RxJava is good at! If you squint a bit, you might be able to tell that the effect handler resembles Observable transformers from RxJava. They are in fact compatible: the mobius-rx / mobius-rx2 modules contain utilities to convert to and from Observable transformers, so that you can use transformers as effect handlers. You\u2019ll get some examples of this in the next section .","title":"Using DataEnum and AutoValue"},{"location":"getting-started/logging-and-error-handling/","text":"Logging and Error Handling \u00b6 Logging \u00b6 In addition to the business-logic level logging capabilities that you can get from configuring a MobiusLoop instance with a MobiusLoop.Logger , Mobius also uses SLF4J for internal logging. These messages - especially at ERROR and WARN level - can sometimes be useful to get access to. For that, you'll need to set up a logging framework for your application as described in the SLF4J documentation . We don't use an open source logging framework at Spotify, so we do not have any recommendation for what to use for Android, but there seem to be a few options. Error Handling \u00b6 Mobius generally tries to expose programmer errors (normally manifesting as RuntimeException s) by simply crashing. When using WorkRunner s, crashing isn't really possible, because what actually happens to an uncaught exception depends on the thread's UncaughtExceptionHandler . Mobius's default behaviour in that situation is to log the exception at ERROR level, and then ignore it. If you wish to do something else - like crash the entire application or report the exception to some other system - then you can do so through configuring an error handler via com.spotify.mobius.MobiusHooks.setErrorHandler .","title":"Logging and Error Handling"},{"location":"getting-started/logging-and-error-handling/#logging-and-error-handling","text":"","title":"Logging and Error Handling"},{"location":"getting-started/logging-and-error-handling/#logging","text":"In addition to the business-logic level logging capabilities that you can get from configuring a MobiusLoop instance with a MobiusLoop.Logger , Mobius also uses SLF4J for internal logging. These messages - especially at ERROR and WARN level - can sometimes be useful to get access to. For that, you'll need to set up a logging framework for your application as described in the SLF4J documentation . We don't use an open source logging framework at Spotify, so we do not have any recommendation for what to use for Android, but there seem to be a few options.","title":"Logging"},{"location":"getting-started/logging-and-error-handling/#error-handling","text":"Mobius generally tries to expose programmer errors (normally manifesting as RuntimeException s) by simply crashing. When using WorkRunner s, crashing isn't really possible, because what actually happens to an uncaught exception depends on the thread's UncaughtExceptionHandler . Mobius's default behaviour in that situation is to log the exception at ERROR level, and then ignore it. If you wish to do something else - like crash the entire application or report the exception to some other system - then you can do so through configuring an error handler via com.spotify.mobius.MobiusHooks.setErrorHandler .","title":"Error Handling"},{"location":"getting-started/mobius-and-android/","text":"Mobius and Android \u00b6 Connecting a MobiusLoop to Android \u00b6 As discussed when talking about configuration, a MobiusLoop.Factory is useful if you want to be able to start the same loop many times from different starting points. One example of this is when using a MobiusLoop in Android. Whether you\u2019re using Activities, Fragments, or some other abstraction, you typically have some concept of restoring state. There may or may not be a saved state available when your component starts, but if there is some saved state, you should start from it instead from starting from a default state. On top of that, there is usually pause/resume where you have to pause execution and resume from where you left off. These cases are examples of starting from different model objects, and the reason why we use MobiusLoop.Factory when connecting Mobius to Android. It allows Mobius to keep track of state for you, and create new loops as required. For our example we will start by creating a factory: MobiusLoop . Factory < MyModel , MyEvent , MyEffect > loopFactory = Mobius . loop ( myUpdate , myEffectHandler ) . init ( myInit ) . eventSource ( myEventSource ) . logger ( AndroidLogger . tag ( \"my_app\" )); In this example we hook up the loop factory to a Fragment, but the same pattern applies for other Android components with a lifecycle. We will create a MobiusLoop.Controller to help us control the lifecycle of loops, which you normally do by calling Mobius.controller(...) . However, in order to get model callbacks on the UI thread, we\u2019ll use MobiusAndroid.controller() instead. You can find it in the mobius-android module, and create it like this: MobiusLoop . Controller < MyModel , MyEvent > controller = MobiusAndroid . controller ( loopFactory , MyModel . createDefault ()); Connecting the MobiusLoop.Controller to a Fragment \u00b6 Now that we\u2019ve created a MobiusLoop.Controller , we need to hook it up to the lifecycle events of our Fragment: public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { rootView = inflater . inflate (...); button = ( Button ) mRootView . findViewById ( R . id . button ); textView = ( TextView ) mRootView . findViewById ( R . id . text ); controller . connect ( this :: connectViews ); if ( savedInstanceState != null ) { String value = savedInstanceState . getString ( \"value\" ); controller . replaceModel ( MyModel . create ( value )); } return rootView ; } @Override public void onDestroyView () { super . onDestroyView (); controller . disconnect (); } @Override public void onResume () { super . onResume (); controller . start (); } @Override public void onPause () { super . onPause (); controller . stop (); } @Override public void onSaveInstanceState ( @NonNull Bundle outState ) { super . onSaveInstanceState ( outState ); MyModel model = controller . getModel (); outState . putString ( \"value\" , model . getValue ()); } In this example we\u2019re storing state using the regular state restore mechanism of Android, but you could just as well use ViewModel (from Android Architecture Components) or any other mechanism to keep track of model objects during configuration changes. Most of this isn\u2019t particularly strange or unexpected, but there is one part we\u2019ve left out: this::connectViews . The argument to MobiusLoop.Controller.connect(...) is actually a Connectable , the same interface that we used for effect handlers earlier. However this one is a Connectable<M, E> instead of a Connectable<F, E> - in other words, it receives Models instead of Effects. We implement it in a way similar to how we implemented the effect handler: private Connection < MyModel > connectViews ( Consumer < MyEvent > eventConsumer ) { // send events to the consumer when the button is pressed button . setOnClickListener ( view -> eventConsumer . accept ( MyEvent . buttonPressed ())); return new Connection < MyModel > () { public void accept ( MyModel model ) { // this will be called whenever there is a new model textView . setText ( model . getValue ()); } public void dispose () { // don't forget to remove listeners when the UI is disconnected button . setOnClickListener ( null ); } }; } This becomes the one place where we hook up event listeners to the UI and update the UI based on the model. And that\u2019s it: a new MobiusLoop gets created whenever the Fragment starts, and it\u2019ll stop and restart from where it left off whenever the fragment is paused/resumed. Furthermore, it supports state restore, and it cleans up after itself when the Fragment is destroyed. Using RxJava with MobiusLoop.Controller \u00b6 Just like RxJava helped us with effect handlers, it can also make our life easier when connecting a UI. Both the effect handlers and the UI that you connect to MobiusLoop.Controller use the same interface, so all utilities for Connectables can be used here, too. When it comes to RxJava, we have RxConnectables that enable us to turn an Observable transformer into a Connectable . Using rxbinding makes implementing connectViews a very nice experience. The connectViews we had before will now look like this: public Observable < MyEvent > connectViews ( Observable < MyModel > models ) { Disposable modelDisposable = models . subscribe ( model -> textView . setText ( model . getValue ())); return RxView . clicks ( button ) . map ( click -> MyEvent . buttonPressed ()) . doOnDispose ( modelDisposable :: dispose ); } And the only other thing that we need to change is the MobiusLoop.Controller.connect(...) call: public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { // ... mController . connect ( RxConnectables . fromTransformer ( this :: connectViews )); // ... } And that\u2019s it! If you have many event streams, you can combine them with Observable.merge(...) / Observable.mergeArray(...) , and if there are many subscriptions to the model, you can put them all in a CompositeDisposable : public Observable < MyEvent > connectViews ( Observable < MyModel > models ) { CompositeDisposable disposables = new CompositeDisposable (); disposables . add ( models . subscribe ( model -> textView1 . setText ( model . getValue1 ()))); disposables . add ( models . subscribe ( model -> textView2 . setText ( model . getValue2 ()))); return Observable . mergeArray ( RxView . clicks ( button1 ). map ( c -> MyEvent . button1Pressed ()), RxView . clicks ( button2 ). map ( c -> MyEvent . button2Pressed ()) ). doOnDispose ( disposables :: dispose ); }","title":"Mobius and Android"},{"location":"getting-started/mobius-and-android/#mobius-and-android","text":"","title":"Mobius and Android"},{"location":"getting-started/mobius-and-android/#connecting-a-mobiusloop-to-android","text":"As discussed when talking about configuration, a MobiusLoop.Factory is useful if you want to be able to start the same loop many times from different starting points. One example of this is when using a MobiusLoop in Android. Whether you\u2019re using Activities, Fragments, or some other abstraction, you typically have some concept of restoring state. There may or may not be a saved state available when your component starts, but if there is some saved state, you should start from it instead from starting from a default state. On top of that, there is usually pause/resume where you have to pause execution and resume from where you left off. These cases are examples of starting from different model objects, and the reason why we use MobiusLoop.Factory when connecting Mobius to Android. It allows Mobius to keep track of state for you, and create new loops as required. For our example we will start by creating a factory: MobiusLoop . Factory < MyModel , MyEvent , MyEffect > loopFactory = Mobius . loop ( myUpdate , myEffectHandler ) . init ( myInit ) . eventSource ( myEventSource ) . logger ( AndroidLogger . tag ( \"my_app\" )); In this example we hook up the loop factory to a Fragment, but the same pattern applies for other Android components with a lifecycle. We will create a MobiusLoop.Controller to help us control the lifecycle of loops, which you normally do by calling Mobius.controller(...) . However, in order to get model callbacks on the UI thread, we\u2019ll use MobiusAndroid.controller() instead. You can find it in the mobius-android module, and create it like this: MobiusLoop . Controller < MyModel , MyEvent > controller = MobiusAndroid . controller ( loopFactory , MyModel . createDefault ());","title":"Connecting a MobiusLoop to Android"},{"location":"getting-started/mobius-and-android/#connecting-the-mobiusloopcontroller-to-a-fragment","text":"Now that we\u2019ve created a MobiusLoop.Controller , we need to hook it up to the lifecycle events of our Fragment: public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { rootView = inflater . inflate (...); button = ( Button ) mRootView . findViewById ( R . id . button ); textView = ( TextView ) mRootView . findViewById ( R . id . text ); controller . connect ( this :: connectViews ); if ( savedInstanceState != null ) { String value = savedInstanceState . getString ( \"value\" ); controller . replaceModel ( MyModel . create ( value )); } return rootView ; } @Override public void onDestroyView () { super . onDestroyView (); controller . disconnect (); } @Override public void onResume () { super . onResume (); controller . start (); } @Override public void onPause () { super . onPause (); controller . stop (); } @Override public void onSaveInstanceState ( @NonNull Bundle outState ) { super . onSaveInstanceState ( outState ); MyModel model = controller . getModel (); outState . putString ( \"value\" , model . getValue ()); } In this example we\u2019re storing state using the regular state restore mechanism of Android, but you could just as well use ViewModel (from Android Architecture Components) or any other mechanism to keep track of model objects during configuration changes. Most of this isn\u2019t particularly strange or unexpected, but there is one part we\u2019ve left out: this::connectViews . The argument to MobiusLoop.Controller.connect(...) is actually a Connectable , the same interface that we used for effect handlers earlier. However this one is a Connectable<M, E> instead of a Connectable<F, E> - in other words, it receives Models instead of Effects. We implement it in a way similar to how we implemented the effect handler: private Connection < MyModel > connectViews ( Consumer < MyEvent > eventConsumer ) { // send events to the consumer when the button is pressed button . setOnClickListener ( view -> eventConsumer . accept ( MyEvent . buttonPressed ())); return new Connection < MyModel > () { public void accept ( MyModel model ) { // this will be called whenever there is a new model textView . setText ( model . getValue ()); } public void dispose () { // don't forget to remove listeners when the UI is disconnected button . setOnClickListener ( null ); } }; } This becomes the one place where we hook up event listeners to the UI and update the UI based on the model. And that\u2019s it: a new MobiusLoop gets created whenever the Fragment starts, and it\u2019ll stop and restart from where it left off whenever the fragment is paused/resumed. Furthermore, it supports state restore, and it cleans up after itself when the Fragment is destroyed.","title":"Connecting the MobiusLoop.Controller to a Fragment"},{"location":"getting-started/mobius-and-android/#using-rxjava-with-mobiusloopcontroller","text":"Just like RxJava helped us with effect handlers, it can also make our life easier when connecting a UI. Both the effect handlers and the UI that you connect to MobiusLoop.Controller use the same interface, so all utilities for Connectables can be used here, too. When it comes to RxJava, we have RxConnectables that enable us to turn an Observable transformer into a Connectable . Using rxbinding makes implementing connectViews a very nice experience. The connectViews we had before will now look like this: public Observable < MyEvent > connectViews ( Observable < MyModel > models ) { Disposable modelDisposable = models . subscribe ( model -> textView . setText ( model . getValue ())); return RxView . clicks ( button ) . map ( click -> MyEvent . buttonPressed ()) . doOnDispose ( modelDisposable :: dispose ); } And the only other thing that we need to change is the MobiusLoop.Controller.connect(...) call: public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { // ... mController . connect ( RxConnectables . fromTransformer ( this :: connectViews )); // ... } And that\u2019s it! If you have many event streams, you can combine them with Observable.merge(...) / Observable.mergeArray(...) , and if there are many subscriptions to the model, you can put them all in a CompositeDisposable : public Observable < MyEvent > connectViews ( Observable < MyModel > models ) { CompositeDisposable disposables = new CompositeDisposable (); disposables . add ( models . subscribe ( model -> textView1 . setText ( model . getValue1 ()))); disposables . add ( models . subscribe ( model -> textView2 . setText ( model . getValue2 ()))); return Observable . mergeArray ( RxView . clicks ( button1 ). map ( c -> MyEvent . button1Pressed ()), RxView . clicks ( button2 ). map ( c -> MyEvent . button2Pressed ()) ). doOnDispose ( disposables :: dispose ); }","title":"Using RxJava with MobiusLoop.Controller"},{"location":"getting-started/mobius-and-rx-java/","text":"Mobius and RxJava \u00b6 The primary use case for RxJava in Mobius is to execute effects, but because both are reactive frameworks, they play quite well together in general. Since the update function in Mobius deals with keeping track of state and deciding what should happen when, you can remove a lot of such logic from your Observable chains. In a sense, Mobius can help you deal with state and state transitions in RxJava. For example, search-as-you-type is complicated to do with RxJava. Every time the text changes, you send a request to the backend: Observable < String > input = // ... Observable < Result > result = input . flatMap ( text -> api . searchForText ( text )); This would mostly work, but the problem is that flatMap doesn\u2019t define in which order responses come back, so you might get the wrong result arriving last! You can use concatMap , but then you would instead block on waiting for all intermediate results, so it\u2019d get choppy if you type fast. You can use switchMap , but that aborts outstanding requests when the text changes, so if you type faster than responses arrive, you won't see anything until you stop typing. Let\u2019s say that the following is the behaviour we want: As long as we haven\u2019t received the result that matches what\u2019s currently entered into the text box, display all results as they come in, but when we get the response that matches the text box, ignore all further results. It is certainly possible to solve this type of problem with RxJava, but designing such observable chains often end up requiring an in-depth understanding of RxJava, using very specific combinations of operators, and understanding which values will be emitted where and when. If you\u2019re dealing with a problem that inherently is complex, Mobius won\u2019t necessarily make it less complex. However since Mobius has a single synchronization point through which all events go (that is, the update function), you are usually able to express desired behaviours as rules by using DataEnum\u2019s map(...) function and simple if -statements. These rules typically are easier to test and modify than a big RxJava chain, since it's just a pure function that describes them. Let\u2019s take a look at how the search-as-you-type behaviour can be implemented with Mobius. First we need our data objects: @AutoValue public abstract class Model { public abstract String query (); public abstract Result result (); public abstract boolean waitingForResult (); // ... create, builder, etc. } @DataEnum interface Event_datenum { dataenum_case TextChanged ( String text ); dataenum_case SearchResult ( String query , Result result ); dataenum_case SearchError ( String query ); } @DataEnum interface Effect_datenum { dataenum_case SearchRequest ( String query ); dataenum_case ShowErrorMessage ( String message ); } Let\u2019s write an update function for this: static Next < Model , Effect > update ( Model model , Event event ) { return event . map ( textChanged -> { // always send a search request if the text changes, and // mark that we are waiting for results return next ( model . toBuilder () . query ( textChanged . text ()) . waitingForResult ( true ) . build (), effects ( Effect . searchRequest ( text ))); }, searchResult -> { // ignore search results if we're not waiting for anything, // this allows us to drop events that arrive too late. if ( ! model . waitingForResult ()) { return noChange (); } // if the result query matches the model query, store the result // and stop waiting for any further results. if ( model . query (). equals ( searchResult . query ())) { return next ( model . toBuilder () . result ( searchResult . result ()) . waitingForResult ( false ) . build ()); } // if we are waiting for results, but this wasn't the result // we are waiting for, just update the model with this // intermediate result. return next ( model . toBuilder () . result ( searchResult . result ()) . build ()); }, searchError -> { // ignore search errors if we're not waiting for anything, // this allows us to drop errors if we already have a response to // the query we're after. if ( ! model . waitingForResult ()) { return noChange (); } // if the query matches the model query, we need to tell the // user. if ( model . query (). equals ( searchError . query ())) { return dispatch ( effects ( Effects . showErrorMessage ( \"search request failed\" ))); } // otherwise, just ignore the error, there are other requests in // flight that may succeed. return noChange (); } ); } This is not necessarily the best solution to search-as-you-type, but it reveals how we can express our behaviours as rules in the update function. One benefit of the simplicity of the update function is that it gives us a lot of flexibility. For example, you can easily modify it to use more complex criteria for when an result should be ignored (for example, what if we\u2019re erasing text in the field and get a late result for a longer query?), or add a sequence number to each effect and ignore anything that arrives out of order. We can also implement request throttling, etc., in the update function, but it\u2019s usually easier to do that with RxJava. Let\u2019s create an effect handler for Effect.SearchRequest to see what this looks like. With RxJava you implement effect-handling with Observable transformers, or by using references to methods that have the same signature as transformers: public Observable < Event > effectHandler ( Observable < Effect > effects ) { return effects . ofType ( Effect . SearchRequest . class ) . debounce ( 200 , TimeUnit . MILLISECONDS ) . flatMap ( request -> api . searchForText ( request . query ()) . map ( result -> Event . searchResult ( request . query (), result )) . onErrorReturn ( err -> Event . searchError ( request . query ()))); } We can use RxConnectables.fromTransformer(...) to convert the transformer into a Connectable and pass it to Mobius.loop(...) , but it\u2019s usually easier to just use RxMobius.loop(...) which does that for you: MobiusLoop < Model , Event , Effect > loop = RxMobius . loop ( Example :: update , this :: effectHandler ) . startFrom ( Model . create ( \"\" , Result . EMPTY , false )); RxMobius.subtypeEffectHandler() \u00b6 One nice thing about the subclasses-approach of defining effects in Mobius is that we can use the type of each effect to determine what it is. RxMobius has a utility that leverages this and enables you to register an effect handler per effect type. We can write the handler for each individual effect as a transformer, just like we did before, but instead of taking an Effect as argument it takes specific effect types as its argument (for example, Effect.SearchRequest ). The handler will then only get effects of that type passed to it, and no casting is required: public Observable < Event > handleSearchRequest ( Observable < Effect . SearchRequest > requests ) { return requests . debounce ( 200 , TimeUnit . MILLISECONDS ) . flatMap ( request -> api . searchForText ( request . query ()) . map ( result -> Event . searchResult ( request . query (), result )) . onErrorReturn ( err -> Event . searchError ( request . query ()))); } After writing individual handlers for all effects, we can then create a subtype effect handler and register the handlers: ObservableTransformer < Effect , Event > rxEffectHandler = RxMobius . < Effect , Event > subtypeEffectHandler () // Effect Handlers can be an ObservableTransformer . addTransformer ( Effect . SearchRequest . class , this :: handleSearchRequest ) // They can also be a Consumer<F> (eg. Consumer<ShowErrorMessage>) . addConsumer ( Effect . ShowErrorMessage . class , view :: showErrorMessage , AndroidSchedulers . mainThread ()) // Or an Action . addAction ( Effect . SomethingElse . class , this :: handleSomethingElse ) // Or a Function<F, E> (eg. Function<SaveToDb, Event>) . addFunction ( Effect . SaveToDb . class , this :: handleSavingToDb ) . build (); This means that eg. whenever a SearchRequest effect is received, it gets routed to the handleSearchRequest observable transformer. All events from transformers are then merged back into one stream and sent back to the update function. The effect handler that subtypeEffectHandler() creates is an observable transformer too, so when creating our loop we will again use RxMobius.loop() instead of Mobius.loop() : MobiusLoop < Model , Event , Effect > loop = RxMobius . loop ( Example :: update , rxEffectHandler ) . startFrom ( Model . create ( \"\" , Result . EMPTY , false ));","title":"Mobius an RxJava"},{"location":"getting-started/mobius-and-rx-java/#mobius-and-rxjava","text":"The primary use case for RxJava in Mobius is to execute effects, but because both are reactive frameworks, they play quite well together in general. Since the update function in Mobius deals with keeping track of state and deciding what should happen when, you can remove a lot of such logic from your Observable chains. In a sense, Mobius can help you deal with state and state transitions in RxJava. For example, search-as-you-type is complicated to do with RxJava. Every time the text changes, you send a request to the backend: Observable < String > input = // ... Observable < Result > result = input . flatMap ( text -> api . searchForText ( text )); This would mostly work, but the problem is that flatMap doesn\u2019t define in which order responses come back, so you might get the wrong result arriving last! You can use concatMap , but then you would instead block on waiting for all intermediate results, so it\u2019d get choppy if you type fast. You can use switchMap , but that aborts outstanding requests when the text changes, so if you type faster than responses arrive, you won't see anything until you stop typing. Let\u2019s say that the following is the behaviour we want: As long as we haven\u2019t received the result that matches what\u2019s currently entered into the text box, display all results as they come in, but when we get the response that matches the text box, ignore all further results. It is certainly possible to solve this type of problem with RxJava, but designing such observable chains often end up requiring an in-depth understanding of RxJava, using very specific combinations of operators, and understanding which values will be emitted where and when. If you\u2019re dealing with a problem that inherently is complex, Mobius won\u2019t necessarily make it less complex. However since Mobius has a single synchronization point through which all events go (that is, the update function), you are usually able to express desired behaviours as rules by using DataEnum\u2019s map(...) function and simple if -statements. These rules typically are easier to test and modify than a big RxJava chain, since it's just a pure function that describes them. Let\u2019s take a look at how the search-as-you-type behaviour can be implemented with Mobius. First we need our data objects: @AutoValue public abstract class Model { public abstract String query (); public abstract Result result (); public abstract boolean waitingForResult (); // ... create, builder, etc. } @DataEnum interface Event_datenum { dataenum_case TextChanged ( String text ); dataenum_case SearchResult ( String query , Result result ); dataenum_case SearchError ( String query ); } @DataEnum interface Effect_datenum { dataenum_case SearchRequest ( String query ); dataenum_case ShowErrorMessage ( String message ); } Let\u2019s write an update function for this: static Next < Model , Effect > update ( Model model , Event event ) { return event . map ( textChanged -> { // always send a search request if the text changes, and // mark that we are waiting for results return next ( model . toBuilder () . query ( textChanged . text ()) . waitingForResult ( true ) . build (), effects ( Effect . searchRequest ( text ))); }, searchResult -> { // ignore search results if we're not waiting for anything, // this allows us to drop events that arrive too late. if ( ! model . waitingForResult ()) { return noChange (); } // if the result query matches the model query, store the result // and stop waiting for any further results. if ( model . query (). equals ( searchResult . query ())) { return next ( model . toBuilder () . result ( searchResult . result ()) . waitingForResult ( false ) . build ()); } // if we are waiting for results, but this wasn't the result // we are waiting for, just update the model with this // intermediate result. return next ( model . toBuilder () . result ( searchResult . result ()) . build ()); }, searchError -> { // ignore search errors if we're not waiting for anything, // this allows us to drop errors if we already have a response to // the query we're after. if ( ! model . waitingForResult ()) { return noChange (); } // if the query matches the model query, we need to tell the // user. if ( model . query (). equals ( searchError . query ())) { return dispatch ( effects ( Effects . showErrorMessage ( \"search request failed\" ))); } // otherwise, just ignore the error, there are other requests in // flight that may succeed. return noChange (); } ); } This is not necessarily the best solution to search-as-you-type, but it reveals how we can express our behaviours as rules in the update function. One benefit of the simplicity of the update function is that it gives us a lot of flexibility. For example, you can easily modify it to use more complex criteria for when an result should be ignored (for example, what if we\u2019re erasing text in the field and get a late result for a longer query?), or add a sequence number to each effect and ignore anything that arrives out of order. We can also implement request throttling, etc., in the update function, but it\u2019s usually easier to do that with RxJava. Let\u2019s create an effect handler for Effect.SearchRequest to see what this looks like. With RxJava you implement effect-handling with Observable transformers, or by using references to methods that have the same signature as transformers: public Observable < Event > effectHandler ( Observable < Effect > effects ) { return effects . ofType ( Effect . SearchRequest . class ) . debounce ( 200 , TimeUnit . MILLISECONDS ) . flatMap ( request -> api . searchForText ( request . query ()) . map ( result -> Event . searchResult ( request . query (), result )) . onErrorReturn ( err -> Event . searchError ( request . query ()))); } We can use RxConnectables.fromTransformer(...) to convert the transformer into a Connectable and pass it to Mobius.loop(...) , but it\u2019s usually easier to just use RxMobius.loop(...) which does that for you: MobiusLoop < Model , Event , Effect > loop = RxMobius . loop ( Example :: update , this :: effectHandler ) . startFrom ( Model . create ( \"\" , Result . EMPTY , false ));","title":"Mobius and RxJava"},{"location":"getting-started/mobius-and-rx-java/#rxmobiussubtypeeffecthandler","text":"One nice thing about the subclasses-approach of defining effects in Mobius is that we can use the type of each effect to determine what it is. RxMobius has a utility that leverages this and enables you to register an effect handler per effect type. We can write the handler for each individual effect as a transformer, just like we did before, but instead of taking an Effect as argument it takes specific effect types as its argument (for example, Effect.SearchRequest ). The handler will then only get effects of that type passed to it, and no casting is required: public Observable < Event > handleSearchRequest ( Observable < Effect . SearchRequest > requests ) { return requests . debounce ( 200 , TimeUnit . MILLISECONDS ) . flatMap ( request -> api . searchForText ( request . query ()) . map ( result -> Event . searchResult ( request . query (), result )) . onErrorReturn ( err -> Event . searchError ( request . query ()))); } After writing individual handlers for all effects, we can then create a subtype effect handler and register the handlers: ObservableTransformer < Effect , Event > rxEffectHandler = RxMobius . < Effect , Event > subtypeEffectHandler () // Effect Handlers can be an ObservableTransformer . addTransformer ( Effect . SearchRequest . class , this :: handleSearchRequest ) // They can also be a Consumer<F> (eg. Consumer<ShowErrorMessage>) . addConsumer ( Effect . ShowErrorMessage . class , view :: showErrorMessage , AndroidSchedulers . mainThread ()) // Or an Action . addAction ( Effect . SomethingElse . class , this :: handleSomethingElse ) // Or a Function<F, E> (eg. Function<SaveToDb, Event>) . addFunction ( Effect . SaveToDb . class , this :: handleSavingToDb ) . build (); This means that eg. whenever a SearchRequest effect is received, it gets routed to the handleSearchRequest observable transformer. All events from transformers are then merged back into one stream and sent back to the update function. The effect handler that subtypeEffectHandler() creates is an observable transformer too, so when creating our loop we will again use RxMobius.loop() instead of Mobius.loop() : MobiusLoop < Model , Event , Effect > loop = RxMobius . loop ( Example :: update , rxEffectHandler ) . startFrom ( Model . create ( \"\" , Result . EMPTY , false ));","title":"RxMobius.subtypeEffectHandler()"},{"location":"patterns/events-and-effects/","text":"Defining Events and Effects \u00b6 Event and Effect objects are very similar. They have different roles in a Mobius loop , but both are immutable data objects that get passed around as messages. As a consequence, both events and effects usually get defined in the same way, and it is frequently a good idea to define them using the same pattern. In the rest of this document we refer to them collectively as messages . Different ways to define messages \u00b6 From the Mobius framework\u2019s point of view, the message types are opaque, so it's up to you to define what they are and what they mean. The sole constraint is all instances of a kind of message must have a single type that they implement. So all Events for a given loop must share a type, and all Effects must share a type. There are many approaches to defining messages, but they can roughly be divided into the following categories: Enumerations \u00b6 This is the basic kind of message. Each message is an enum , an int , or even a String . There can be no data attached to a dispatched message, so it's usually a limiting approach except in very small or restricted loops. We occasionally use this type of message in the documentation for example code. Tagged object \u00b6 An extension to enumerations. It can for example be a simple java class with a couple of data fields plus an extra \"tag\" that explains which kind of message it is, and therefore which fields are supposed to be read. Another example is to have a Map<String, String> with parameters, each specific message storing things by using different keys in the map. However, this is not a type-safe approach and you must be careful to only read \"correct\" parameters, and make sure that you enter the correct data when you create the objects. Subclasses \u00b6 This is the recommended way of defining messages. You have a common parent message type, for example an interface MyEvent , and you make all your Events implement this interface. Each subclass can then have its own data that makes sense for that particular message. At first glance it looks like subclasses will make it tedious to check the type of each message and manually cast them. In fact, it seems to possess some of the same problems as tagged objects. On top of that, manually defining all the event and effect classes would lead to a lot of hard-to-maintain and error-prone boilerplate code. It might seem like a good solution to put an update method on each message subclass, and have the \" main\" update function delegate to it. However, this is considered an anti-pattern in Mobius, as it inserts business logic into messages that are supposed to be simple data carriers, thereby making the code paths harder to follow, refactoring more difficult, and limiting your options in how you structure the update function of the loop. Even though there are some apparent hurdles, it turns out we have some tools at our disposal that make working with subclasses a lot easier, as well as type-safe. Kotlin: Sealed classes \u00b6 If you are using Kotlin, there's a perfect tool for this: sealed classes . Sealed classes are a way to define subclasses that are \"tied together\" with a parent class, very much like a Java enum: sealed class MyEvent data class Text ( val text : String ) : MyEvent () data class Number ( val number : Int ) : MyEvent () object Reset : MyEvent () Note: If no data is associated with a message, we define it as an object instead of a data class . In your update function you are then able to use a when expression to \"switch\" the message type: when ( event ) { // event is smart-cast to a \"Text\" and you can access event.text is Text -> /* code */ // event is smart-cast to a \"Number\" and you can access event.number is Number -> /* code */ // event is smart-cast to a \"Reset\" and there are no fields is Reset -> /* code */ } This way you are only able to access fields that are available for each message, and defining the messages gets very straight-forward. Java: DataEnum \u00b6 Java has support for creating a kind of \"sealed class\" (using inner classes and a private super constructor), but there is no mechanism for switching that is as easy to use as the when expression in Kotlin. To deal with this, we've created a companion library to Mobius called DataEnum (as in enum values with associated data). It is an annotation processor that generates a kind of \"sealed classes\" similar to the ones you have in Kotlin. You define messages by creating an interface that looks like this: @DataEnum interface MyEvent_dataenum { dataenum_case Text ( String text ); dataenum_case Number ( int number ); dataenum_case Reset (); } It resembles the sealed classes in Kotlin, and you should think about it the same way. Based on this specification, DataEnum generates a class MyEvent with inner subclasses MyEvent.Text , MyEvent.Number , and MyEvent.Reset . The MyEvent class also serves as a factory for creating events: MyEvent event1 = MyEvent . text ( \"hello\" ); MyEvent event2 = MyEvent . number ( 42 ); MyEvent event3 = MyEvent . reset (); Classes generated by DataEnum always have a map method, which works like Kotlin's when expression (compare to the Kotlin code above): event . map ( // event is cast to Text and you can access text.text() text -> /* code */ , // event is cast to Number and you can access number.number() number -> /* code */ , // event is cast to Reset and there are no fields reset -> /* code */ ); If you look closely you see that map is given three lambdas, and it works by making the event call the lambda that matches its own type (basically it's a variation of the Visitor pattern). It's a bit of a trick, but it leads to code that is type-safe and both looks and behaves like Kotlin's when expressions. You can read more about DataEnum and its capabilities at the project on GitHub . In most of the Mobius documentation we use and about DataEnum, but those patterns work equally well with Kotlin sealed classes or manually defined messages.","title":"Events and Effects"},{"location":"patterns/events-and-effects/#defining-events-and-effects","text":"Event and Effect objects are very similar. They have different roles in a Mobius loop , but both are immutable data objects that get passed around as messages. As a consequence, both events and effects usually get defined in the same way, and it is frequently a good idea to define them using the same pattern. In the rest of this document we refer to them collectively as messages .","title":"Defining Events and Effects"},{"location":"patterns/events-and-effects/#different-ways-to-define-messages","text":"From the Mobius framework\u2019s point of view, the message types are opaque, so it's up to you to define what they are and what they mean. The sole constraint is all instances of a kind of message must have a single type that they implement. So all Events for a given loop must share a type, and all Effects must share a type. There are many approaches to defining messages, but they can roughly be divided into the following categories:","title":"Different ways to define messages"},{"location":"patterns/events-and-effects/#enumerations","text":"This is the basic kind of message. Each message is an enum , an int , or even a String . There can be no data attached to a dispatched message, so it's usually a limiting approach except in very small or restricted loops. We occasionally use this type of message in the documentation for example code.","title":"Enumerations"},{"location":"patterns/events-and-effects/#tagged-object","text":"An extension to enumerations. It can for example be a simple java class with a couple of data fields plus an extra \"tag\" that explains which kind of message it is, and therefore which fields are supposed to be read. Another example is to have a Map<String, String> with parameters, each specific message storing things by using different keys in the map. However, this is not a type-safe approach and you must be careful to only read \"correct\" parameters, and make sure that you enter the correct data when you create the objects.","title":"Tagged object"},{"location":"patterns/events-and-effects/#subclasses","text":"This is the recommended way of defining messages. You have a common parent message type, for example an interface MyEvent , and you make all your Events implement this interface. Each subclass can then have its own data that makes sense for that particular message. At first glance it looks like subclasses will make it tedious to check the type of each message and manually cast them. In fact, it seems to possess some of the same problems as tagged objects. On top of that, manually defining all the event and effect classes would lead to a lot of hard-to-maintain and error-prone boilerplate code. It might seem like a good solution to put an update method on each message subclass, and have the \" main\" update function delegate to it. However, this is considered an anti-pattern in Mobius, as it inserts business logic into messages that are supposed to be simple data carriers, thereby making the code paths harder to follow, refactoring more difficult, and limiting your options in how you structure the update function of the loop. Even though there are some apparent hurdles, it turns out we have some tools at our disposal that make working with subclasses a lot easier, as well as type-safe.","title":"Subclasses"},{"location":"patterns/events-and-effects/#kotlin-sealed-classes","text":"If you are using Kotlin, there's a perfect tool for this: sealed classes . Sealed classes are a way to define subclasses that are \"tied together\" with a parent class, very much like a Java enum: sealed class MyEvent data class Text ( val text : String ) : MyEvent () data class Number ( val number : Int ) : MyEvent () object Reset : MyEvent () Note: If no data is associated with a message, we define it as an object instead of a data class . In your update function you are then able to use a when expression to \"switch\" the message type: when ( event ) { // event is smart-cast to a \"Text\" and you can access event.text is Text -> /* code */ // event is smart-cast to a \"Number\" and you can access event.number is Number -> /* code */ // event is smart-cast to a \"Reset\" and there are no fields is Reset -> /* code */ } This way you are only able to access fields that are available for each message, and defining the messages gets very straight-forward.","title":"Kotlin: Sealed classes"},{"location":"patterns/events-and-effects/#java-dataenum","text":"Java has support for creating a kind of \"sealed class\" (using inner classes and a private super constructor), but there is no mechanism for switching that is as easy to use as the when expression in Kotlin. To deal with this, we've created a companion library to Mobius called DataEnum (as in enum values with associated data). It is an annotation processor that generates a kind of \"sealed classes\" similar to the ones you have in Kotlin. You define messages by creating an interface that looks like this: @DataEnum interface MyEvent_dataenum { dataenum_case Text ( String text ); dataenum_case Number ( int number ); dataenum_case Reset (); } It resembles the sealed classes in Kotlin, and you should think about it the same way. Based on this specification, DataEnum generates a class MyEvent with inner subclasses MyEvent.Text , MyEvent.Number , and MyEvent.Reset . The MyEvent class also serves as a factory for creating events: MyEvent event1 = MyEvent . text ( \"hello\" ); MyEvent event2 = MyEvent . number ( 42 ); MyEvent event3 = MyEvent . reset (); Classes generated by DataEnum always have a map method, which works like Kotlin's when expression (compare to the Kotlin code above): event . map ( // event is cast to Text and you can access text.text() text -> /* code */ , // event is cast to Number and you can access number.number() number -> /* code */ , // event is cast to Reset and there are no fields reset -> /* code */ ); If you look closely you see that map is given three lambdas, and it works by making the event call the lambda that matches its own type (basically it's a variation of the Visitor pattern). It's a bit of a trick, but it leads to code that is type-safe and both looks and behaves like Kotlin's when expressions. You can read more about DataEnum and its capabilities at the project on GitHub . In most of the Mobius documentation we use and about DataEnum, but those patterns work equally well with Kotlin sealed classes or manually defined messages.","title":"Java: DataEnum"},{"location":"patterns/immutability/","text":"Immutability \u00b6 Most objects in Mobius are required to be immutable. Immutability imposes a constraint on what your objects can do, therefore making them easier to reason about. The Mobius framework is in fact based on the principle that Model , Event , and Effect objects are immutable \u2013 it wouldn\u2019t be possible to have Mobius without this constraint. For an object to be immutable, it is not enough to make all member fields final. Any object referred to must also be immutable. If any field references a mutable object, then your object is not immutable (the exception being if the field isn\u2019t important for behaviour; an example is java.util.String instances that are immutable even though they cache the hash code in a mutable field). In particular be careful with arrays - they might be marked as final , but that only makes the reference to the array final, not the values inside the array. It might be tempting sometimes to use e.g. a plain List instead of an ImmutableList , and you might in fact get away with it, especially if it\u2019s only your own code that touches the data. But it\u2019s strongly advised to avoid this, as it is a potential source of errors, and breaking the immutability contract means you no longer get any guarantees from the framework. While it might not seem like a big issue, it might have unintended consequences or cause problems later on.","title":"Immutability"},{"location":"patterns/immutability/#immutability","text":"Most objects in Mobius are required to be immutable. Immutability imposes a constraint on what your objects can do, therefore making them easier to reason about. The Mobius framework is in fact based on the principle that Model , Event , and Effect objects are immutable \u2013 it wouldn\u2019t be possible to have Mobius without this constraint. For an object to be immutable, it is not enough to make all member fields final. Any object referred to must also be immutable. If any field references a mutable object, then your object is not immutable (the exception being if the field isn\u2019t important for behaviour; an example is java.util.String instances that are immutable even though they cache the hash code in a mutable field). In particular be careful with arrays - they might be marked as final , but that only makes the reference to the array final, not the values inside the array. It might be tempting sometimes to use e.g. a plain List instead of an ImmutableList , and you might in fact get away with it, especially if it\u2019s only your own code that touches the data. But it\u2019s strongly advised to avoid this, as it is a potential source of errors, and breaking the immutability contract means you no longer get any guarantees from the framework. While it might not seem like a big issue, it might have unintended consequences or cause problems later on.","title":"Immutability"},{"location":"patterns/models/","text":"Defining Models \u00b6 Just as Events and Effects, Model objects are opaque to the Mobius framework itself. They should be immutable, but other than that they can be anything. Since the update function in Mobius represents state transitions in a state machine, it\u2019s natural to see the model as representing the current state of that machine. When defining a model for the state machine, a spectrum of approaches is available to us, ranging from a strict finite-state-machine approach, to a more loosely defined \u201cput everything in a bucket\u201d approach. All states use different classes \u00b6 When you consider finite-state machines, having one class per state makes sense. The machine can only be in one state at the time, and each state only possesses data that makes sense in that state. Let\u2019s draft a small example of this using DataEnum: @DataEnum interface Model_dataenum { dataenum_case WaitingForData (); dataenum_case Loaded ( String data ); dataenum_case Error ( String message ); } We now have three classes, WaitingForData , Loaded , and Error , and at a given time our model can only be one of them. As you see, the data field only exists in the Loaded state, so you don\u2019t have to check for null when accessing it, because you will only be Loaded if data is non-null. This approach is perfect for small loops with few states, or when you want to be assured that all corner cases are covered. However, there are some drawbacks to this approach, particularly when there are many states that start overlapping. For example, if there is an \u201coffline\u201d state, you might want to distinguish offline-but-no-data from offline-but-with-data \u2012 this quickly leads to an explosion of the number of states and state transitions that must covered, and you might end up with plenty of boilerplate just to copy data from one state to another. All states use the same class \u00b6 This approach is on the other end of the spectrum compared to the previous one. You use flags to keep track of whether data is loaded, etc., and store everything at the object\u2019s \u201ctop level\u201d. Let\u2019s look at AutoValue for this example, and let\u2019s include offline as an extra flag, too: @AutoValue public abstract class Model { public abstract boolean loaded (); public abstract boolean error (); public abstract boolean offline (); @Nullable public abstract String data (); @Nullable public abstract String errorMessage (); // ... create method and/or builder, etc. ... } Note: You might end up with a lot fields that can be null . There can also be invalid state combinations (in the case above, both loaded and error can be true at the same time), or cases with both data and an error message. This is of course an exaggerated case, but when you approach this end of the spectrum, you might get more special cases that must be handled carefully. This kind of model tends to be easier to modify than the previous approach when requirements change and new states are required, and it is a lot easier to create new versions of model objects from old ones, especially if you use AutoValue's toBuilder() . It is often advantageous to start with this kind of model, as it is the most straightforward one to create and the easiest one to evolve as requirements change. Hybrid approach \u00b6 One good way to gain the conveniences of a single model, but still avoid invalid states, is to borrow some ideas from both previous approaches and go for a hybrid solution. The first model provided a good way to deal with the regular states, and it was its offline scenario that messed things up. So instead of duplicate all states of the first model, let\u2019s combine the first approach with the second one: @DataEnum interface LoadingState_dataenum { dataenum_case WaitingForData (); dataenum_case Loaded ( String data ); dataenum_case Error ( String message ); } @AutoValue public abstract class Model { public abstract boolean offline (); public abstract LoadingState loadingState (); // ... create method and/or builder, etc. ... } Now it\u2019s possible to be both loaded and offline at the same time! We\u2019ve combined two state machines by putting them next to each other \u2012 one keeps track of data loading, and the other keeps track of whether you\u2019re offline. Also, this approach scales up to multiple parallel state machines, or even state-machines-within-state-machines. Note that this isn\u2019t necessarily a perfect model: for example, maybe the waiting-for-data and offline states are incompatible. If it\u2019s really important for you to deal with this state in the model, you\u2019d have to go for something a bit more like the first approach, but if it\u2019s just a single combination that is troublesome now, the hybrid solution is often a worthwhile trade-off. The hybrid provides a more flexible model that is easier to modify when requirements change, and you\u2019re still avoiding most edge cases (for example, in this version data is never null, and you can\u2019t have both data and an error message). Some useful tricks for model objects \u00b6 Since model objects are supposed to be immutable, you need to create new ones whenever you want to change anything. Since this will be a common occurrence, and you want code to be easy to read, you should create helper methods to carry out these changes. In this section we will look at some ways you can do this. Let\u2019s imagine we have a Model for a todo-list. It might look something like this: @AutoValue public abstract class Task { public abstract String description (); public abstract boolean complete (); public static Task create ( String description , boolean complete ) { return new AutoValue_Task ( description , complete ); } } @AutoValue public abstract class Model { public enum Filter { ALL , INCOMPLETE , COMPLETE } public abstract List < Task > tasks (); public abstract Filter filter (); public static Model create ( String description , Filter filter ) { return new AutoValue_Model ( tasks , filter ); } } Note: Avoid arrays and Lists in the model like this, since they are mutable. Instead you should use something like ImmutableList from Guava. That being said, we use List s in these examples to keep them short. Java: AutoValue \u00b6 If you use AutoValue (recommended when you use Java), builder() and toBuilder() will be your best friends. Define a builder like this: @AutoValue public abstract class Task { // ... public static Builder builder () { return new AutoValue_Task . Builder (); } public abstract Builder toBuilder (); @AutoValue.Builder public abstract static class Builder { public abstract Builder description ( String description ); public abstract Builder complete ( boolean complete ); public abstract Task build (); } } Note: Writing this by hand can get cumbersome. You can make your job easier by using one of the AutoValue plugins for IntelliJ to generate it automatically. Now we either create a new Task from scratch with a fluent API: Task task1 = Task . builder () . description ( \"hello\" ) . complete ( false ) . build (); Or we create modified versions of an existing object: Task task2 = oldTask . toBuilder () . complete ( true ) . build (); You can also set default values by applying them in the static builder() method: public static Builder builder () { return new AutoValue_Task . Builder () . complete ( false ); } Kotlin: Data classes \u00b6 If you use Kotlin, things get a bit easier: use data classes and their .copy() method: data class Task ( val description : String , val complete : Boolean ) val task1 = Task ( \"hello\" , false ) val task2 = task1 . copy ( complete = true ) with -methods \u00b6 The builders are powerful, but sometimes they don\u2019t read well in the Update function: static Next < Model , Effect > update ( Model model , Event event ) { // ... return event . map ( // ... completeChanged -> { int index = completeChanged . index (); Task oldTask = model . tasks (). get ( index ); Task newTask = oldTask . toBuilder () . complete ( completeChanged . complete ()) . build (); List < Task > newTasks = new ArrayList <> (); newTasks . addAll ( model . tasks ()); newTasks . set ( index , newTask ); return next ( model . toBuilder () . tasks ( newTasks ) . build ()); } // ... ); } A lot of the noise is due to us working with immutable objects, but it doesn\u2019t have to be this messy. There is a lot going on in this function and it\u2019s not easy to see what it is: The old task is fetched from the old list of tasks A new task is created from the old task A new list is created from the old list The old task is replaced by the new task in the new list The old list is replaced by the new list in the model This is merely mechanical juggling of data - what we\u2019re really trying to say is: Change complete of the task at position index . In other words, we\u2019d like our update function to look like this: static Next < Model , Effect > update ( Model model , Event event ) { // ... return event . map ( // ... completeChanged -> { return next ( model . withTaskComplete ( completeChanged . index (), completeChanged . complete ())); } // ... ); } We implement this step-by-step in the model, starting with the Task class: @AutoValue public abstract class Task { // ... public Task withComplete ( boolean complete ) { return toBuilder () . complete ( complete ) . build (); } } This enables us to easily create copies of a Task with a different value for complete() . We can also use the same pattern to replace a single task in Model : @AutoValue public abstract class Model { // ... public Model replaceTask ( int index , Task task ) { List < Task > newTasks = new ArrayList <> (); newTasks . addAll ( tasks ()); newTasks . set ( index , task ); return toBuilder () . tasks ( newTasks ) . build (); } } Finally we combine the methods and create our withTaskComplete(...) : @AutoValue public abstract class Model { // ... public Model withTaskComplete ( int index , boolean complete ) { Task oldTask = tasks (). get ( index ); return replaceTask ( index , oldTask . withComplete ( complete )); } } We still have to do more or less the same things, but this a more fluent API for the job. We are also able to reuse some of these helper methods. For example, Model.replaceTask(...) will be useful if we want to change the description of a task.","title":"Models"},{"location":"patterns/models/#defining-models","text":"Just as Events and Effects, Model objects are opaque to the Mobius framework itself. They should be immutable, but other than that they can be anything. Since the update function in Mobius represents state transitions in a state machine, it\u2019s natural to see the model as representing the current state of that machine. When defining a model for the state machine, a spectrum of approaches is available to us, ranging from a strict finite-state-machine approach, to a more loosely defined \u201cput everything in a bucket\u201d approach.","title":"Defining Models"},{"location":"patterns/models/#all-states-use-different-classes","text":"When you consider finite-state machines, having one class per state makes sense. The machine can only be in one state at the time, and each state only possesses data that makes sense in that state. Let\u2019s draft a small example of this using DataEnum: @DataEnum interface Model_dataenum { dataenum_case WaitingForData (); dataenum_case Loaded ( String data ); dataenum_case Error ( String message ); } We now have three classes, WaitingForData , Loaded , and Error , and at a given time our model can only be one of them. As you see, the data field only exists in the Loaded state, so you don\u2019t have to check for null when accessing it, because you will only be Loaded if data is non-null. This approach is perfect for small loops with few states, or when you want to be assured that all corner cases are covered. However, there are some drawbacks to this approach, particularly when there are many states that start overlapping. For example, if there is an \u201coffline\u201d state, you might want to distinguish offline-but-no-data from offline-but-with-data \u2012 this quickly leads to an explosion of the number of states and state transitions that must covered, and you might end up with plenty of boilerplate just to copy data from one state to another.","title":"All states use different classes"},{"location":"patterns/models/#all-states-use-the-same-class","text":"This approach is on the other end of the spectrum compared to the previous one. You use flags to keep track of whether data is loaded, etc., and store everything at the object\u2019s \u201ctop level\u201d. Let\u2019s look at AutoValue for this example, and let\u2019s include offline as an extra flag, too: @AutoValue public abstract class Model { public abstract boolean loaded (); public abstract boolean error (); public abstract boolean offline (); @Nullable public abstract String data (); @Nullable public abstract String errorMessage (); // ... create method and/or builder, etc. ... } Note: You might end up with a lot fields that can be null . There can also be invalid state combinations (in the case above, both loaded and error can be true at the same time), or cases with both data and an error message. This is of course an exaggerated case, but when you approach this end of the spectrum, you might get more special cases that must be handled carefully. This kind of model tends to be easier to modify than the previous approach when requirements change and new states are required, and it is a lot easier to create new versions of model objects from old ones, especially if you use AutoValue's toBuilder() . It is often advantageous to start with this kind of model, as it is the most straightforward one to create and the easiest one to evolve as requirements change.","title":"All states use the same class"},{"location":"patterns/models/#hybrid-approach","text":"One good way to gain the conveniences of a single model, but still avoid invalid states, is to borrow some ideas from both previous approaches and go for a hybrid solution. The first model provided a good way to deal with the regular states, and it was its offline scenario that messed things up. So instead of duplicate all states of the first model, let\u2019s combine the first approach with the second one: @DataEnum interface LoadingState_dataenum { dataenum_case WaitingForData (); dataenum_case Loaded ( String data ); dataenum_case Error ( String message ); } @AutoValue public abstract class Model { public abstract boolean offline (); public abstract LoadingState loadingState (); // ... create method and/or builder, etc. ... } Now it\u2019s possible to be both loaded and offline at the same time! We\u2019ve combined two state machines by putting them next to each other \u2012 one keeps track of data loading, and the other keeps track of whether you\u2019re offline. Also, this approach scales up to multiple parallel state machines, or even state-machines-within-state-machines. Note that this isn\u2019t necessarily a perfect model: for example, maybe the waiting-for-data and offline states are incompatible. If it\u2019s really important for you to deal with this state in the model, you\u2019d have to go for something a bit more like the first approach, but if it\u2019s just a single combination that is troublesome now, the hybrid solution is often a worthwhile trade-off. The hybrid provides a more flexible model that is easier to modify when requirements change, and you\u2019re still avoiding most edge cases (for example, in this version data is never null, and you can\u2019t have both data and an error message).","title":"Hybrid approach"},{"location":"patterns/models/#some-useful-tricks-for-model-objects","text":"Since model objects are supposed to be immutable, you need to create new ones whenever you want to change anything. Since this will be a common occurrence, and you want code to be easy to read, you should create helper methods to carry out these changes. In this section we will look at some ways you can do this. Let\u2019s imagine we have a Model for a todo-list. It might look something like this: @AutoValue public abstract class Task { public abstract String description (); public abstract boolean complete (); public static Task create ( String description , boolean complete ) { return new AutoValue_Task ( description , complete ); } } @AutoValue public abstract class Model { public enum Filter { ALL , INCOMPLETE , COMPLETE } public abstract List < Task > tasks (); public abstract Filter filter (); public static Model create ( String description , Filter filter ) { return new AutoValue_Model ( tasks , filter ); } } Note: Avoid arrays and Lists in the model like this, since they are mutable. Instead you should use something like ImmutableList from Guava. That being said, we use List s in these examples to keep them short.","title":"Some useful tricks for model objects"},{"location":"patterns/models/#java-autovalue","text":"If you use AutoValue (recommended when you use Java), builder() and toBuilder() will be your best friends. Define a builder like this: @AutoValue public abstract class Task { // ... public static Builder builder () { return new AutoValue_Task . Builder (); } public abstract Builder toBuilder (); @AutoValue.Builder public abstract static class Builder { public abstract Builder description ( String description ); public abstract Builder complete ( boolean complete ); public abstract Task build (); } } Note: Writing this by hand can get cumbersome. You can make your job easier by using one of the AutoValue plugins for IntelliJ to generate it automatically. Now we either create a new Task from scratch with a fluent API: Task task1 = Task . builder () . description ( \"hello\" ) . complete ( false ) . build (); Or we create modified versions of an existing object: Task task2 = oldTask . toBuilder () . complete ( true ) . build (); You can also set default values by applying them in the static builder() method: public static Builder builder () { return new AutoValue_Task . Builder () . complete ( false ); }","title":"Java: AutoValue"},{"location":"patterns/models/#kotlin-data-classes","text":"If you use Kotlin, things get a bit easier: use data classes and their .copy() method: data class Task ( val description : String , val complete : Boolean ) val task1 = Task ( \"hello\" , false ) val task2 = task1 . copy ( complete = true )","title":"Kotlin: Data classes"},{"location":"patterns/models/#with-methods","text":"The builders are powerful, but sometimes they don\u2019t read well in the Update function: static Next < Model , Effect > update ( Model model , Event event ) { // ... return event . map ( // ... completeChanged -> { int index = completeChanged . index (); Task oldTask = model . tasks (). get ( index ); Task newTask = oldTask . toBuilder () . complete ( completeChanged . complete ()) . build (); List < Task > newTasks = new ArrayList <> (); newTasks . addAll ( model . tasks ()); newTasks . set ( index , newTask ); return next ( model . toBuilder () . tasks ( newTasks ) . build ()); } // ... ); } A lot of the noise is due to us working with immutable objects, but it doesn\u2019t have to be this messy. There is a lot going on in this function and it\u2019s not easy to see what it is: The old task is fetched from the old list of tasks A new task is created from the old task A new list is created from the old list The old task is replaced by the new task in the new list The old list is replaced by the new list in the model This is merely mechanical juggling of data - what we\u2019re really trying to say is: Change complete of the task at position index . In other words, we\u2019d like our update function to look like this: static Next < Model , Effect > update ( Model model , Event event ) { // ... return event . map ( // ... completeChanged -> { return next ( model . withTaskComplete ( completeChanged . index (), completeChanged . complete ())); } // ... ); } We implement this step-by-step in the model, starting with the Task class: @AutoValue public abstract class Task { // ... public Task withComplete ( boolean complete ) { return toBuilder () . complete ( complete ) . build (); } } This enables us to easily create copies of a Task with a different value for complete() . We can also use the same pattern to replace a single task in Model : @AutoValue public abstract class Model { // ... public Model replaceTask ( int index , Task task ) { List < Task > newTasks = new ArrayList <> (); newTasks . addAll ( tasks ()); newTasks . set ( index , task ); return toBuilder () . tasks ( newTasks ) . build (); } } Finally we combine the methods and create our withTaskComplete(...) : @AutoValue public abstract class Model { // ... public Model withTaskComplete ( int index , boolean complete ) { Task oldTask = tasks (). get ( index ); return replaceTask ( index , oldTask . withComplete ( complete )); } } We still have to do more or less the same things, but this a more fluent API for the job. We are also able to reuse some of these helper methods. For example, Model.replaceTask(...) will be useful if we want to change the description of a task.","title":"with-methods"},{"location":"patterns/pure-vs-impure-functions/","text":"Pure vs Impure Functions \u00b6 The term pure function , means that the function's return value is completely determined by its inputs and that executing the function produces no side effects. A function that is not pure is called \u2018impure\u2019. This distinction is important for primarily the following reasons: Pure functions are fundamentally simple: the fact that they are perfectly predictable makes them easy to understand, and makes mistakes easy to correct. This in turn makes them into great building blocks when constructing complex business logic. Pure functions are extremely easy to test, and it's even feasible to do so exhaustively in the sense of 'covering all input values that lead to different branches'. In contrast, impure functions - which is what you get with object-oriented programming where an object encapsulates mutable state and behaviour - are harder to understand and test. Generally, you will need a debugger to understand the current state of the object, and to see which sequence of events led up to an unexpected state that triggers a bug. In Mobius, we encourage using pure functions where feasible, and impure functions only where necessary. For some more thoughts on the benefits of pure functions, see for instance http://blog.agiledeveloper.com/2015/12/benefits-of-pure-functions.html.","title":"Pure vs Impure Functions"},{"location":"patterns/pure-vs-impure-functions/#pure-vs-impure-functions","text":"The term pure function , means that the function's return value is completely determined by its inputs and that executing the function produces no side effects. A function that is not pure is called \u2018impure\u2019. This distinction is important for primarily the following reasons: Pure functions are fundamentally simple: the fact that they are perfectly predictable makes them easy to understand, and makes mistakes easy to correct. This in turn makes them into great building blocks when constructing complex business logic. Pure functions are extremely easy to test, and it's even feasible to do so exhaustively in the sense of 'covering all input values that lead to different branches'. In contrast, impure functions - which is what you get with object-oriented programming where an object encapsulates mutable state and behaviour - are harder to understand and test. Generally, you will need a debugger to understand the current state of the object, and to see which sequence of events led up to an unexpected state that triggers a bug. In Mobius, we encourage using pure functions where feasible, and impure functions only where necessary. For some more thoughts on the benefits of pure functions, see for instance http://blog.agiledeveloper.com/2015/12/benefits-of-pure-functions.html.","title":"Pure vs Impure Functions"},{"location":"reference-guide/effect-handler/","text":"Effect Handler \u00b6 Effect Handlers receive Effects , execute them, and may produce Events as a result. A Mobius loop has a single Effect Handler, which usually is composed of individual Effect Handlers for each kind of Effect. (See Mobius and RxJava for how to compose RxJava-based Effect Handlers.) If the Effect handler needs data from the Model , that should always be passed along with the Effect. It would be possible for an Effect Handler to subscribe to Model updates, but that would introduce races and reduce simplicity. Effect Handlers must never throw exceptions if something goes wrong. Doing so will crash or leave the loop in an undefined state. Instead, if an error occurs during Effect execution, that should be converted into an Event that can be used by the Update function to decide on how to proceed. Connections \u00b6 An Effect Handler is connected to a MobiusLoop via a Connection - something the loop can use to send Effects to the handler, and to send an indication that it\u2019s time to shut down. Once an Effect handler's Connection has been shut down (via the dispose() method), sending Events to the loop will cause an exception. If an Effect Handler instance might be shared by multiple loops, extra care needs to be taken to ensure it\u2019s safe for reuse. A way that this can happen in a Spotify context is if a user is viewing two different albums at the same time. Depending on how things are wired up, the same Effect handler might be reused for both albums. If an Effect Handler can only be safely connected to a limited number of loops (usually that limit is 1), it should throw a ConnectionLimitExceeded exception if further connection attempts are made. This will prevent hard-to-find bugs in case Effect handlers unexpectedly end up being shared.","title":"Effect Handler"},{"location":"reference-guide/effect-handler/#effect-handler","text":"Effect Handlers receive Effects , execute them, and may produce Events as a result. A Mobius loop has a single Effect Handler, which usually is composed of individual Effect Handlers for each kind of Effect. (See Mobius and RxJava for how to compose RxJava-based Effect Handlers.) If the Effect handler needs data from the Model , that should always be passed along with the Effect. It would be possible for an Effect Handler to subscribe to Model updates, but that would introduce races and reduce simplicity. Effect Handlers must never throw exceptions if something goes wrong. Doing so will crash or leave the loop in an undefined state. Instead, if an error occurs during Effect execution, that should be converted into an Event that can be used by the Update function to decide on how to proceed.","title":"Effect Handler"},{"location":"reference-guide/effect-handler/#connections","text":"An Effect Handler is connected to a MobiusLoop via a Connection - something the loop can use to send Effects to the handler, and to send an indication that it\u2019s time to shut down. Once an Effect handler's Connection has been shut down (via the dispose() method), sending Events to the loop will cause an exception. If an Effect Handler instance might be shared by multiple loops, extra care needs to be taken to ensure it\u2019s safe for reuse. A way that this can happen in a Spotify context is if a user is viewing two different albums at the same time. Depending on how things are wired up, the same Effect handler might be reused for both albums. If an Effect Handler can only be safely connected to a limited number of loops (usually that limit is 1), it should throw a ConnectionLimitExceeded exception if further connection attempts are made. This will prevent hard-to-find bugs in case Effect handlers unexpectedly end up being shared.","title":"Connections"},{"location":"reference-guide/effect/","text":"Effect \u00b6 Effect objects are used by the Update function to request that the Effect Handler executes impure code. Impure code either has measurable side-effects or has an output that isn't completely determined by its input parameters. For example, this can be sending a request to a backend service, reading something from disk, changing the value of a shared (global/singleton) object, etc. The objects themselves are immutable data objects just like the Model and Event objects. Effects and Events are similar in that they are both messages. The difference is in the direction as seen from the Update function - an Event is something that happened that the business logic needs to react to, whereas an Effect is something that the business logic wants to make happen in the outside world. Effects are commands, in the CQRS definition of the term. Note that Mobius provides no guarantees regarding the execution order of Effects - not even in the sense that Effects resulting from Event N will be processed before Event N+1 is. Guidelines for designing Effects \u00b6 Use imperative form in the names, reflecting what should happen: SendLoginRequest , PersistUser , LoadPlaylistData , etc. Effects should be value objects without business logic. Prefer using something similar to DataEnum (in Java) or sealed classes (in Kotlin) for Effect definitions.","title":"Effect"},{"location":"reference-guide/effect/#effect","text":"Effect objects are used by the Update function to request that the Effect Handler executes impure code. Impure code either has measurable side-effects or has an output that isn't completely determined by its input parameters. For example, this can be sending a request to a backend service, reading something from disk, changing the value of a shared (global/singleton) object, etc. The objects themselves are immutable data objects just like the Model and Event objects. Effects and Events are similar in that they are both messages. The difference is in the direction as seen from the Update function - an Event is something that happened that the business logic needs to react to, whereas an Effect is something that the business logic wants to make happen in the outside world. Effects are commands, in the CQRS definition of the term. Note that Mobius provides no guarantees regarding the execution order of Effects - not even in the sense that Effects resulting from Event N will be processed before Event N+1 is.","title":"Effect"},{"location":"reference-guide/effect/#guidelines-for-designing-effects","text":"Use imperative form in the names, reflecting what should happen: SendLoginRequest , PersistUser , LoadPlaylistData , etc. Effects should be value objects without business logic. Prefer using something similar to DataEnum (in Java) or sealed classes (in Kotlin) for Effect definitions.","title":"Guidelines for designing Effects"},{"location":"reference-guide/event-source/","text":"Event Source \u00b6 An Event Source is used to send external signals into a Mobius Loop as Events . The typical use case is to listen for things like: Network connectivity changes (online/offline) Timers (periodic ticks, eg. once per second) Headphones connected/disconnected Events received by BroadcastReceiver s etc. In principle an Event Source could be used to send events from the UI (like clicks) but this is discouraged. Instead prefer using MobiusLoop.dispatchEvent(...) or a Connectable if you use MobiusLoop.Controller . Structurally an Event Source is very similar to Effect Handlers but an Event Source does not need any Effects to be triggered before starting to send Events. You can configure it by calling .eventSource(...) on a MobiusLoop.Builder : MobiusLoop . Builder < Model , Event , Effect > loopBuilder = Mobius . loop ( update , effectHandler ) . eventSource ( myEventSource ); If you are using RxJava you can wrap any Observables that emits your Event type into an EventSource : Observable < Event . First > first = ... Observable < Event . Second > second = ... Observable < Event . Third > third = ... EventSource < Event > eventSource = RxEventSources . fromObservables ( first , second , third );","title":"Event Source"},{"location":"reference-guide/event-source/#event-source","text":"An Event Source is used to send external signals into a Mobius Loop as Events . The typical use case is to listen for things like: Network connectivity changes (online/offline) Timers (periodic ticks, eg. once per second) Headphones connected/disconnected Events received by BroadcastReceiver s etc. In principle an Event Source could be used to send events from the UI (like clicks) but this is discouraged. Instead prefer using MobiusLoop.dispatchEvent(...) or a Connectable if you use MobiusLoop.Controller . Structurally an Event Source is very similar to Effect Handlers but an Event Source does not need any Effects to be triggered before starting to send Events. You can configure it by calling .eventSource(...) on a MobiusLoop.Builder : MobiusLoop . Builder < Model , Event , Effect > loopBuilder = Mobius . loop ( update , effectHandler ) . eventSource ( myEventSource ); If you are using RxJava you can wrap any Observables that emits your Event type into an EventSource : Observable < Event . First > first = ... Observable < Event . Second > second = ... Observable < Event . Third > third = ... EventSource < Event > eventSource = RxEventSources . fromObservables ( first , second , third );","title":"Event Source"},{"location":"reference-guide/event/","text":"Event \u00b6 Events are immutable data objects that represent that something has happened. Events are what drive a Mobius loop forward, and it is only when an Event is received that business logic is executed and state is evolved. The purpose of Events is to allow the Update function to know about when things happen and allow it to make decisions. This means that sending an Event is the only way to get new data into the Update function, and the only way to cause the Model to change. In other words, all data you want to put into the Model when the loop is running has to be sent to Mobius using an Event, or be derived from data received in Events. Events are also the only thing that can trigger an Effect . This is because that just like with Model changes, it's the Update function that decides when Effects should happen, and those decisions are always triggered by Events. Event names should describe things from the perspective of the business logic domain rather than from the UI design. For example, LoginRequest is a better event name in a search setting than LoginButtonClicked . A reason for that is that there may be more than one way of interacting with the UI that leads to triggering the same Event. For instance, you could request a login by hitting return from the password field, or by clicking on the login button. Note: Not everything occurring in a UI needs to be an Event. An example of that is something that happens purely in the UI without affecting the business logic, such as an animation. Intermediate steps in the animation should probably occur silently, but there might be an event emitted by the UI at the end of the animation, to trigger a transition to a different view. A good rule of thumb is: \"Does the Update need to make any decisions when this happens?\" Events can be divided into three categories based on the source of the event: interaction, effect feedback, and external: Interaction events . This is the primary type of Events, and they are in a sense \u201cthe public API\u201d of a Mobius loop. They are typically triggered by a user interacting with the UI (or something analogous for UI-less programs). Consequently, these Events are usually formulated as actions or intentions rather than desired behaviour. A couple of examples of this kind of Event are: SearchQueryChanged , SkipTrackRequested , ShuffleClicked . Effect feedback events . Effect Handlers will often need to communicate back progress of their effects. That feedback also takes the form of an Event. For example, loading data from a backend service could result in a DataLoaded event if the HTTP call succeeds or a DataLoadingFailed event if the call fails. External events . Some Events are neither interactions nor a result of an Effect - those are the external Events that you receive from an Event Source . One way to think about the external Events are that they are feedback Events from the outside world. Examples of this kind of events are: ConnectivityChanged, LoginStateChanged, HeadphonesDisconnected. Note that this distinction between different types of events is only used when reasoning about Events. In code, all Events are treated the same way, and there is no difference between the sources when an Event reaches the Update function. Guidelines for Events \u00b6 See the guide about defining Events and Effects . Events should have names based on user intent, and they will typically be in past tense. For example: LoginRequested , QueryChanged , AddressChanged , etc.","title":"Event"},{"location":"reference-guide/event/#event","text":"Events are immutable data objects that represent that something has happened. Events are what drive a Mobius loop forward, and it is only when an Event is received that business logic is executed and state is evolved. The purpose of Events is to allow the Update function to know about when things happen and allow it to make decisions. This means that sending an Event is the only way to get new data into the Update function, and the only way to cause the Model to change. In other words, all data you want to put into the Model when the loop is running has to be sent to Mobius using an Event, or be derived from data received in Events. Events are also the only thing that can trigger an Effect . This is because that just like with Model changes, it's the Update function that decides when Effects should happen, and those decisions are always triggered by Events. Event names should describe things from the perspective of the business logic domain rather than from the UI design. For example, LoginRequest is a better event name in a search setting than LoginButtonClicked . A reason for that is that there may be more than one way of interacting with the UI that leads to triggering the same Event. For instance, you could request a login by hitting return from the password field, or by clicking on the login button. Note: Not everything occurring in a UI needs to be an Event. An example of that is something that happens purely in the UI without affecting the business logic, such as an animation. Intermediate steps in the animation should probably occur silently, but there might be an event emitted by the UI at the end of the animation, to trigger a transition to a different view. A good rule of thumb is: \"Does the Update need to make any decisions when this happens?\" Events can be divided into three categories based on the source of the event: interaction, effect feedback, and external: Interaction events . This is the primary type of Events, and they are in a sense \u201cthe public API\u201d of a Mobius loop. They are typically triggered by a user interacting with the UI (or something analogous for UI-less programs). Consequently, these Events are usually formulated as actions or intentions rather than desired behaviour. A couple of examples of this kind of Event are: SearchQueryChanged , SkipTrackRequested , ShuffleClicked . Effect feedback events . Effect Handlers will often need to communicate back progress of their effects. That feedback also takes the form of an Event. For example, loading data from a backend service could result in a DataLoaded event if the HTTP call succeeds or a DataLoadingFailed event if the call fails. External events . Some Events are neither interactions nor a result of an Effect - those are the external Events that you receive from an Event Source . One way to think about the external Events are that they are feedback Events from the outside world. Examples of this kind of events are: ConnectivityChanged, LoginStateChanged, HeadphonesDisconnected. Note that this distinction between different types of events is only used when reasoning about Events. In code, all Events are treated the same way, and there is no difference between the sources when an Event reaches the Update function.","title":"Event"},{"location":"reference-guide/event/#guidelines-for-events","text":"See the guide about defining Events and Effects . Events should have names based on user intent, and they will typically be in past tense. For example: LoginRequested , QueryChanged , AddressChanged , etc.","title":"Guidelines for Events"},{"location":"reference-guide/init/","text":"Init \u00b6 The init(Model) function is called first when a Mobius loop is started, and can be seen as a special version of the Update function. It takes a Model just like Update, but it does not have any Event as an argument. It returns a First instead of a Next , the difference being that a First always contains a Model, while a Next sometimes contain nothing or only Effects . One good way to think of the Init function is as a request to \u201cresume execution from a particular Model\u201d. This means put the loop in a valid state and send off any required Effects to activate it. An example of putting the loop in a valid state might be that if the old Model was showing an \u201coffline\u201d state, when you restore maybe it would be better to start from a \u201cloading\u201d state and send an Effect to load data. Likewise if the Model already was in a \u201cloading\u201d state, the Init function is responsible for sending an Effect to restart the loading of data. If we don\u2019t do that, then the data won\u2019t ever load, and the user would be stuck in the loading state forever! Providing a custom Init function is not required, but you need to make sure that this doesn\u2019t lead to the loop ending up in undesired states that the user can\u2019t get out of. Guidelines for the Init function \u00b6 The same guidelines apply as for the Update function .","title":"Init"},{"location":"reference-guide/init/#init","text":"The init(Model) function is called first when a Mobius loop is started, and can be seen as a special version of the Update function. It takes a Model just like Update, but it does not have any Event as an argument. It returns a First instead of a Next , the difference being that a First always contains a Model, while a Next sometimes contain nothing or only Effects . One good way to think of the Init function is as a request to \u201cresume execution from a particular Model\u201d. This means put the loop in a valid state and send off any required Effects to activate it. An example of putting the loop in a valid state might be that if the old Model was showing an \u201coffline\u201d state, when you restore maybe it would be better to start from a \u201cloading\u201d state and send an Effect to load data. Likewise if the Model already was in a \u201cloading\u201d state, the Init function is responsible for sending an Effect to restart the loading of data. If we don\u2019t do that, then the data won\u2019t ever load, and the user would be stuck in the loading state forever! Providing a custom Init function is not required, but you need to make sure that this doesn\u2019t lead to the loop ending up in undesired states that the user can\u2019t get out of.","title":"Init"},{"location":"reference-guide/init/#guidelines-for-the-init-function","text":"The same guidelines apply as for the Update function .","title":"Guidelines for the Init function"},{"location":"reference-guide/mobius-loop/","text":"Mobius Loop \u00b6 A Mobius loop receives Events , which are passed to an Update function. As a result of running the Update function, the Model might change, and Effects might get dispatched. The Model can be observed by the user interface, and the Effects are received and executed by an Effect Handler . A Mobius loop is what ties everything together in the Mobius framework. It is responsible for sending events to the Update function, keeping track of the current Model, sending Effects to the Effect Handler, and listening to the Event Source . The normal way to create a loop is by calling Mobius.loop(...) and then starting it using startFrom(...) : MobiusLoop < Model , Event , Effect > loop = Mobius . loop ( Example :: update , this :: effectHandler ) . startFrom ( Model . createDefault ()); You can add an observer if you want to know when the Model changes, but the loop will start even if you don't add any observer: Disposable disposable = loop . observe ( this :: onModelChanged ); The returned disposable can be used to stop observing the loop, but normally you can just use loop.dispose() to shut down the loop and remove all observers at once.","title":"Mobius Loop"},{"location":"reference-guide/mobius-loop/#mobius-loop","text":"A Mobius loop receives Events , which are passed to an Update function. As a result of running the Update function, the Model might change, and Effects might get dispatched. The Model can be observed by the user interface, and the Effects are received and executed by an Effect Handler . A Mobius loop is what ties everything together in the Mobius framework. It is responsible for sending events to the Update function, keeping track of the current Model, sending Effects to the Effect Handler, and listening to the Event Source . The normal way to create a loop is by calling Mobius.loop(...) and then starting it using startFrom(...) : MobiusLoop < Model , Event , Effect > loop = Mobius . loop ( Example :: update , this :: effectHandler ) . startFrom ( Model . createDefault ()); You can add an observer if you want to know when the Model changes, but the loop will start even if you don't add any observer: Disposable disposable = loop . observe ( this :: onModelChanged ); The returned disposable can be used to stop observing the loop, but normally you can just use loop.dispose() to shut down the loop and remove all observers at once.","title":"Mobius Loop"},{"location":"reference-guide/model/","text":"Model \u00b6 The Model is an immutable representation of the internal state and configuration of a Mobius loop . It contains two kinds of data, often overlapping: what you need to make business logic decisions, and what you need to present in the UI. The current Model and the incoming Event is the only input that the Update function is allowed to consider, so anything needed to make decisions or to generate output must be available there. Because the Model is immutable, you will be required to create new instances of your Model whenever it needs to change. This might at first glance seem wasteful, but thanks to everything being immutable, only a shallow copy of the object is necessary \u2013 everything else can safely share references with the previous version of the Model. It might be tempting to put configuration or state as member fields of your Update implementation, but if you do this then the Update function no longer is pure, which in turn means you can\u2019t reason about the loop in the same way. In principle you could break this rule, but just like breaking the immutability contract, that breaks a lot of the assumptions in Mobius and means you should use another framework. When starting a Mobius loop, you will be required to provide a Model that the loop should start from. It could simply be the initial state of the loop, but it could also be a previous Model you want to resume execution from. Since the Update function of a Mobius loop doesn\u2019t have any memory other than the Model, any valid Model should be a valid a starting point for a new loop. Guidelines for Models \u00b6 All the data you need in the Update function must be in the Model and Event . This means any data used when making decisions must be represented in the Model. You should never keep state anywhere else within the Mobius loop. The non-transient UI state should be derivable from the Model . Some UI-only state is unavoidable, but it should be minimised as changes to UI are generally harder to understand and test for than changes in the Model. It will be easier to build a robust loop the simpler the UI is. Avoid expressing UI concerns in the Model . The Model should mostly be concerned with making decisions, not care about rendering. As the Model is used as an input for the rendering, there is of course a certain degree of coupling, but you should still try to express the Model in terms of what the meaning behind something is rather than the representation. An example of this is that in the Model, you should not say isLoginButtonEnabled , but rather canLogin . Strive to use this way of expressing yourself as much as possible, even if the Update function doesn\u2019t make any decisions based on the value. But keep in mind that you should still use your own judgement to decide if it makes sense in your particular case. Sometimes it makes sense for the loop to be concerned about UI, in which case don\u2019t go overboard trying to abstract away the idea. Configuration must be part of the Model . Configuration in this context could for example be the URI of the page (if this loop is for a user profile page, that would be the user profile URI), or which A/B-test group this user is in. If it is an A/B-test that changes behavior, you should not express it in terms of what the test is, but rather what behavior is changed. In other words you should not call it isUserInMutualFriendsTestGroup , but rather shouldShowMutualFriends . Translating from A/B-flags to configuration should be done when instantiating your Model. Do not put behaviour in the Model . The Model should be considered a value object. It is okay to put simple helper methods in the Model to make it easier to create new versions of it, but avoid making decisions in it. The Model in Mobius is just an object that holds some data, and shouldn\u2019t be compared to the \u201cmodel\u201d of MVP or MVC, where it usually also contains domain logic.","title":"Model"},{"location":"reference-guide/model/#model","text":"The Model is an immutable representation of the internal state and configuration of a Mobius loop . It contains two kinds of data, often overlapping: what you need to make business logic decisions, and what you need to present in the UI. The current Model and the incoming Event is the only input that the Update function is allowed to consider, so anything needed to make decisions or to generate output must be available there. Because the Model is immutable, you will be required to create new instances of your Model whenever it needs to change. This might at first glance seem wasteful, but thanks to everything being immutable, only a shallow copy of the object is necessary \u2013 everything else can safely share references with the previous version of the Model. It might be tempting to put configuration or state as member fields of your Update implementation, but if you do this then the Update function no longer is pure, which in turn means you can\u2019t reason about the loop in the same way. In principle you could break this rule, but just like breaking the immutability contract, that breaks a lot of the assumptions in Mobius and means you should use another framework. When starting a Mobius loop, you will be required to provide a Model that the loop should start from. It could simply be the initial state of the loop, but it could also be a previous Model you want to resume execution from. Since the Update function of a Mobius loop doesn\u2019t have any memory other than the Model, any valid Model should be a valid a starting point for a new loop.","title":"Model"},{"location":"reference-guide/model/#guidelines-for-models","text":"All the data you need in the Update function must be in the Model and Event . This means any data used when making decisions must be represented in the Model. You should never keep state anywhere else within the Mobius loop. The non-transient UI state should be derivable from the Model . Some UI-only state is unavoidable, but it should be minimised as changes to UI are generally harder to understand and test for than changes in the Model. It will be easier to build a robust loop the simpler the UI is. Avoid expressing UI concerns in the Model . The Model should mostly be concerned with making decisions, not care about rendering. As the Model is used as an input for the rendering, there is of course a certain degree of coupling, but you should still try to express the Model in terms of what the meaning behind something is rather than the representation. An example of this is that in the Model, you should not say isLoginButtonEnabled , but rather canLogin . Strive to use this way of expressing yourself as much as possible, even if the Update function doesn\u2019t make any decisions based on the value. But keep in mind that you should still use your own judgement to decide if it makes sense in your particular case. Sometimes it makes sense for the loop to be concerned about UI, in which case don\u2019t go overboard trying to abstract away the idea. Configuration must be part of the Model . Configuration in this context could for example be the URI of the page (if this loop is for a user profile page, that would be the user profile URI), or which A/B-test group this user is in. If it is an A/B-test that changes behavior, you should not express it in terms of what the test is, but rather what behavior is changed. In other words you should not call it isUserInMutualFriendsTestGroup , but rather shouldShowMutualFriends . Translating from A/B-flags to configuration should be done when instantiating your Model. Do not put behaviour in the Model . The Model should be considered a value object. It is okay to put simple helper methods in the Model to make it easier to create new versions of it, but avoid making decisions in it. The Model in Mobius is just an object that holds some data, and shouldn\u2019t be compared to the \u201cmodel\u201d of MVP or MVC, where it usually also contains domain logic.","title":"Guidelines for Models"},{"location":"reference-guide/update/","text":"Update \u00b6 The Update interface contains one method: update(Model, Event) . In this section we will refer to this method as the Update function. It is meant to be a function in the functional programming sense of the word, in other words it should be pure. In order for it to be a pure function, there are some constraints you should keep in mind: Keeping the Update function pure \u00b6 The Update function must not have side-effects . You are not allowed mutate any shared memory, write to disk, print a log message, make a network requests, etc. Whether your function has been called once or a million times should have no effect on the rest of the application. If there is any impact you want the function to have on the outside world, you should use an Effect to describe it. The Update function must not depend on external state . This is sort of the inverse of the previous statement. The only things that should have any effect on the return value of the Update function are the Model and the Event that are passed as arguments. This means no System.currentTimeMillis() , using Random , reading from disk, or even reading from shared memory. The only data you may use in the Update function is constants, the current Model object, and the current Event object. Configuration of the Update function must be in the Model . As a follow up to the previous statement, any configuration needed for the Update function must be put in the Model object. You should not have member fields that change the behaviour of the Update function, even if they are immutable. The return value of the Update function \u00b6 There are four possible return values of the Update function: no change, only Effects, new Model, or both a new Model and Effects. These are described using the Next class, which has correspondingly named factory methods: Next . noChange () Next . next ( model ) Next . next ( model , effects ) Next . dispatch ( effects ) If there are no Effects, then no Effect objects will be emitted by the Update, and likewise, if there is no new Model, then no Model will be emitted. Take special note of that last statement - if you don\u2019t return a new Model then no Model will be emitted. It does not matter if the Model has actually changed or not, it is up to the Update function to decide if a Model should be emitted, and therefore whether observers (like the UI) will see a new Model or not. Tips for writing the Update function \u00b6 Start by defining expected behaviours of the Update function . We recommend a specific modelling flow , and that you start by defining the Update function using unit tests. Doing so will help you uncover specification mistakes and corner cases before you spend any time on building out the Update function and, more importantly, the Effect Handlers and the UI. Mobius is a FP pattern, but Java is not a FP language . While the inspiration for Mobius comes from functional programming (FP), writing functional-style code isn\u2019t always the best choice in Java. Sometimes using a for-loop and adding to an array just is easier than using a higher-order transform function and passing it an anonymous class instance. Try to keep your code simple and readable and avoid being too clever. It is allowed to use mutable data structures inside the Update function . The Update function only has to be pure from the outside. If you can simplify the implementation by setting up temporary mutable objects, go for it! It is not necessarily a problem that the Update function is big . As long as you have an easy to understand control flow, an Update function can become quite large without becoming hard to reason about. Do not hesitate to break it down into several smaller static Update functions, eg. break out the handling of a particular Event or everything that happens before data is loaded. Avoid nesting too deeply . Sometimes the Update function can become quite deep when you\u2019re for example first switching on Event just happened, then which state you are in, and finally take action depending on data in the Model. In these cases you usually break out smaller functions that handle just this particular state, Event, etc. You can also use other regular techniques such as early returns or using local variables to store intermediate values.","title":"Update"},{"location":"reference-guide/update/#update","text":"The Update interface contains one method: update(Model, Event) . In this section we will refer to this method as the Update function. It is meant to be a function in the functional programming sense of the word, in other words it should be pure. In order for it to be a pure function, there are some constraints you should keep in mind:","title":"Update"},{"location":"reference-guide/update/#keeping-the-update-function-pure","text":"The Update function must not have side-effects . You are not allowed mutate any shared memory, write to disk, print a log message, make a network requests, etc. Whether your function has been called once or a million times should have no effect on the rest of the application. If there is any impact you want the function to have on the outside world, you should use an Effect to describe it. The Update function must not depend on external state . This is sort of the inverse of the previous statement. The only things that should have any effect on the return value of the Update function are the Model and the Event that are passed as arguments. This means no System.currentTimeMillis() , using Random , reading from disk, or even reading from shared memory. The only data you may use in the Update function is constants, the current Model object, and the current Event object. Configuration of the Update function must be in the Model . As a follow up to the previous statement, any configuration needed for the Update function must be put in the Model object. You should not have member fields that change the behaviour of the Update function, even if they are immutable.","title":"Keeping the Update function pure"},{"location":"reference-guide/update/#the-return-value-of-the-update-function","text":"There are four possible return values of the Update function: no change, only Effects, new Model, or both a new Model and Effects. These are described using the Next class, which has correspondingly named factory methods: Next . noChange () Next . next ( model ) Next . next ( model , effects ) Next . dispatch ( effects ) If there are no Effects, then no Effect objects will be emitted by the Update, and likewise, if there is no new Model, then no Model will be emitted. Take special note of that last statement - if you don\u2019t return a new Model then no Model will be emitted. It does not matter if the Model has actually changed or not, it is up to the Update function to decide if a Model should be emitted, and therefore whether observers (like the UI) will see a new Model or not.","title":"The return value of the Update function"},{"location":"reference-guide/update/#tips-for-writing-the-update-function","text":"Start by defining expected behaviours of the Update function . We recommend a specific modelling flow , and that you start by defining the Update function using unit tests. Doing so will help you uncover specification mistakes and corner cases before you spend any time on building out the Update function and, more importantly, the Effect Handlers and the UI. Mobius is a FP pattern, but Java is not a FP language . While the inspiration for Mobius comes from functional programming (FP), writing functional-style code isn\u2019t always the best choice in Java. Sometimes using a for-loop and adding to an array just is easier than using a higher-order transform function and passing it an anonymous class instance. Try to keep your code simple and readable and avoid being too clever. It is allowed to use mutable data structures inside the Update function . The Update function only has to be pure from the outside. If you can simplify the implementation by setting up temporary mutable objects, go for it! It is not necessarily a problem that the Update function is big . As long as you have an easy to understand control flow, an Update function can become quite large without becoming hard to reason about. Do not hesitate to break it down into several smaller static Update functions, eg. break out the handling of a particular Event or everything that happens before data is loaded. Avoid nesting too deeply . Sometimes the Update function can become quite deep when you\u2019re for example first switching on Event just happened, then which state you are in, and finally take action depending on data in the Model. In these cases you usually break out smaller functions that handle just this particular state, Event, etc. You can also use other regular techniques such as early returns or using local variables to store intermediate values.","title":"Tips for writing the Update function"}]}